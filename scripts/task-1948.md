## Overview

Build an SMB2/3 client from scratch, implementing protocol negotiation, session setup with NTLM/Kerberos authentication, and tree connections to shares. This is the foundation for all SMB-based tools.

### SMB2/3 Protocol Stack

```
┌─────────────────────────────────────────────────────────┐
│                    SMB2/3 Protocol                       │
├─────────────────────────────────────────────────────────┤
│  Tree Connect    │ Access shares (C$, ADMIN$, IPC$)     │
│  Session Setup   │ NTLM/Kerberos authentication         │
│  Negotiate       │ Dialect, capabilities, signing       │
│  Direct TCP      │ Port 445, no NetBIOS                 │
└─────────────────────────────────────────────────────────┘
```

### Implementation

```python
import socket
import struct
import hashlib
import hmac
from typing import Optional, Dict
from Crypto.Cipher import ARC4, AES

class SMB2Client:
    """SMB2/3 protocol implementation"""

    # SMB2 Commands
    SMB2_NEGOTIATE = 0x0000
    SMB2_SESSION_SETUP = 0x0001
    SMB2_TREE_CONNECT = 0x0003
    SMB2_CREATE = 0x0005
    SMB2_READ = 0x0008
    SMB2_WRITE = 0x0009

    # Dialects
    SMB2_DIALECT_202 = 0x0202  # SMB 2.0.2
    SMB2_DIALECT_210 = 0x0210  # SMB 2.1
    SMB2_DIALECT_300 = 0x0300  # SMB 3.0
    SMB2_DIALECT_302 = 0x0302  # SMB 3.0.2
    SMB2_DIALECT_311 = 0x0311  # SMB 3.1.1

    def __init__(self, target: str, port: int = 445):
        self.target = target
        self.port = port
        self.socket = None
        self.session_id = 0
        self.message_id = 0
        self.dialect = None
        self.signing_required = False
        self.session_key = None
        self.tree_ids: Dict[str, int] = {}

    def connect(self) -> bool:
        """Establish TCP connection"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.target, self.port))
            return True
        except Exception as e:
            print(f"Connection failed: {e}")
            return False

    def negotiate(self) -> bool:
        """Negotiate SMB2 dialect and capabilities"""
        # Build Negotiate request
        dialects = struct.pack('<HHHHH',
            self.SMB2_DIALECT_202,
            self.SMB2_DIALECT_210,
            self.SMB2_DIALECT_300,
            self.SMB2_DIALECT_302,
            self.SMB2_DIALECT_311
        )

        negotiate_req = struct.pack('<H', 36)  # StructureSize
        negotiate_req += struct.pack('<H', 5)   # DialectCount
        negotiate_req += struct.pack('<H', 1)   # SecurityMode (signing enabled)
        negotiate_req += struct.pack('<H', 0)   # Reserved
        negotiate_req += struct.pack('<I', 0x7F)  # Capabilities
        negotiate_req += b'\x00' * 16          # ClientGuid
        negotiate_req += struct.pack('<I', 0)   # NegotiateContextOffset
        negotiate_req += struct.pack('<H', 0)   # NegotiateContextCount
        negotiate_req += struct.pack('<H', 0)   # Reserved2
        negotiate_req += dialects

        response = self._send_smb2(self.SMB2_NEGOTIATE, negotiate_req)

        if response:
            # Parse response
            self.dialect = struct.unpack('<H', response[4:6])[0]
            security_mode = struct.unpack('<H', response[2:4])[0]
            self.signing_required = (security_mode & 0x02) != 0

            print(f"[*] Negotiated dialect: 0x{self.dialect:04x}")
            return True

        return False

    def session_setup_ntlm(self, username: str, password: str = None,
                          nt_hash: str = None, domain: str = '') -> bool:
        """Authenticate using NTLM"""
        # Type 1 - Negotiate message
        ntlm_negotiate = self._build_ntlm_type1(domain)

        session_setup = struct.pack('<H', 25)  # StructureSize
        session_setup += struct.pack('<B', 0)   # Flags
        session_setup += struct.pack('<B', 0)   # SecurityMode
        session_setup += struct.pack('<I', 0)   # Capabilities
        session_setup += struct.pack('<I', 0)   # Channel
        session_setup += struct.pack('<H', 88)  # SecurityBufferOffset
        session_setup += struct.pack('<H', len(ntlm_negotiate))
        session_setup += struct.pack('<Q', 0)   # PreviousSessionId
        session_setup += ntlm_negotiate

        response = self._send_smb2(self.SMB2_SESSION_SETUP, session_setup)

        if not response:
            return False

        # Extract Type 2 challenge from response
        sec_buf_len = struct.unpack('<H', response[14:16])[0]
        ntlm_challenge = response[24:24 + sec_buf_len]

        # Parse challenge and build Type 3 response
        challenge = self._parse_ntlm_type2(ntlm_challenge)

        if nt_hash:
            nt_hash_bytes = bytes.fromhex(nt_hash)
        else:
            nt_hash_bytes = hashlib.new('md4', password.encode('utf-16le')).digest()

        ntlm_auth, session_key = self._build_ntlm_type3(
            username, domain, nt_hash_bytes, challenge
        )
        self.session_key = session_key

        # Send Type 3
        session_setup2 = struct.pack('<H', 25)
        session_setup2 += struct.pack('<B', 0)
        session_setup2 += struct.pack('<B', 0)
        session_setup2 += struct.pack('<I', 0)
        session_setup2 += struct.pack('<I', 0)
        session_setup2 += struct.pack('<H', 88)
        session_setup2 += struct.pack('<H', len(ntlm_auth))
        session_setup2 += struct.pack('<Q', 0)
        session_setup2 += ntlm_auth

        response = self._send_smb2(self.SMB2_SESSION_SETUP, session_setup2)

        if response:
            print(f"[+] Authenticated as {domain}\\{username}")
            return True

        return False

    def tree_connect(self, share: str) -> Optional[int]:
        """Connect to share"""
        share_path = f'\\\\{self.target}\\{share}'
        share_bytes = share_path.encode('utf-16le')

        tree_connect = struct.pack('<H', 9)  # StructureSize
        tree_connect += struct.pack('<H', 0)  # Reserved
        tree_connect += struct.pack('<H', 72)  # PathOffset
        tree_connect += struct.pack('<H', len(share_bytes))
        tree_connect += share_bytes

        response = self._send_smb2(self.SMB2_TREE_CONNECT, tree_connect)

        if response:
            tree_id = self._last_tree_id
            self.tree_ids[share] = tree_id
            print(f"[+] Connected to {share}")
            return tree_id

        return None

    def _send_smb2(self, command: int, data: bytes) -> Optional[bytes]:
        """Send SMB2 packet and receive response"""
        # Build SMB2 header (64 bytes)
        header = b'\xfeSMB'  # Protocol ID
        header += struct.pack('<H', 64)  # StructureSize
        header += struct.pack('<H', 0)   # CreditCharge
        header += struct.pack('<I', 0)   # Status
        header += struct.pack('<H', command)
        header += struct.pack('<H', 1)   # CreditRequest
        header += struct.pack('<I', 0)   # Flags
        header += struct.pack('<I', 0)   # NextCommand
        header += struct.pack('<Q', self.message_id)
        header += struct.pack('<I', 0)   # Reserved
        header += struct.pack('<I', 0)   # TreeId
        header += struct.pack('<Q', self.session_id)
        header += b'\x00' * 16          # Signature

        self.message_id += 1
        packet = header + data

        # Sign if required
        if self.signing_required and self.session_key:
            signature = hmac.new(
                self.session_key, packet, hashlib.sha256
            ).digest()[:16]
            packet = packet[:48] + signature + packet[64:]

        # Send with NetBIOS length prefix
        self.socket.send(struct.pack('>I', len(packet)) + packet)

        # Receive response
        resp_len = struct.unpack('>I', self.socket.recv(4))[0]
        response = self.socket.recv(resp_len)

        # Check status
        status = struct.unpack('<I', response[8:12])[0]
        if status != 0 and status != 0xC0000016:
            print(f"[-] SMB2 error: 0x{status:08x}")
            return None

        # Update session ID from response
        self.session_id = struct.unpack('<Q', response[40:48])[0]
        self._last_tree_id = struct.unpack('<I', response[36:40])[0]

        return response[64:]  # Return body


# Usage
client = SMB2Client('192.168.1.100')
if client.connect():
    client.negotiate()
    client.session_setup_ntlm('admin', nt_hash='31d6cfe0d16ae931b73c59d7e0c089c0')
    client.tree_connect('C$')
```

### Key Concepts

- **Dialect Negotiation**: Client and server agree on SMB version (2.0.2 to 3.1.1)
- **Session Setup**: NTLM or Kerberos authentication wrapped in SPNEGO
- **Tree Connect**: Access a specific share after authentication
- **Message Signing**: HMAC-SHA256 with session key for integrity protection
- **Encryption**: SMB3 supports AES encryption for confidentiality

### Practice Tasks

- [ ] Implement TCP connection on port 445
- [ ] Build SMB2 Negotiate request with multiple dialects
- [ ] Parse negotiation response for dialect and capabilities
- [ ] Implement NTLM Type 1/2/3 message handling
- [ ] Add Tree Connect for share access
- [ ] Implement message signing with session key
- [ ] Add pass-the-hash support (use NT hash directly)
- [ ] Handle SMB2 status codes and errors

### Completion Criteria

- [ ] Successfully negotiate dialect with Windows server
- [ ] Authenticate with both password and NT hash
- [ ] Connect to administrative shares (C$, ADMIN$)
- [ ] Signing works when server requires it
- [ ] Handle multiple concurrent tree connections
